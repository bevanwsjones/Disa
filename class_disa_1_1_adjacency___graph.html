<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Disa: Adjacency_Graph&lt; _directed &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Disa
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_disa_1_1_adjacency___graph.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">Adjacency_Graph&lt; _directed &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An graph G(V, E), where V is a set of vertex indices and E is a set of undirected edges connecting the vertices in V.  
 <a href="class_disa_1_1_adjacency___graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="adjacency__graph_8hpp_source.html">adjacency_graph.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af42629b2ddf4987908b086887e3eff30" id="r_af42629b2ddf4987908b086887e3eff30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#af42629b2ddf4987908b086887e3eff30">Adjacency_Graph</a> ()=default</td></tr>
<tr class="memdesc:af42629b2ddf4987908b086887e3eff30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af42629b2ddf4987908b086887e3eff30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e925f4c74b5a028289f5e5a648a826" id="r_ad0e925f4c74b5a028289f5e5a648a826"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#ad0e925f4c74b5a028289f5e5a648a826">Adjacency_Graph</a> (std::initializer_list&lt; <a class="el" href="namespace_disa.html#a5d0458dbd92d3cbd94eddeb318b6d88f">Edge</a> &gt; edge_graph)</td></tr>
<tr class="memdesc:ad0e925f4c74b5a028289f5e5a648a826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction via a list of edges connecting two vertices i and j, where i != j.  <br /></td></tr>
<tr class="separator:ad0e925f4c74b5a028289f5e5a648a826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc378210b6ca44ccaddb93dd1faab93c" id="r_afc378210b6ca44ccaddb93dd1faab93c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#afc378210b6ca44ccaddb93dd1faab93c">~Adjacency_Graph</a> ()=default</td></tr>
<tr class="memdesc:afc378210b6ca44ccaddb93dd1faab93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <br /></td></tr>
<tr class="separator:afc378210b6ca44ccaddb93dd1faab93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0d53746bdfac9e89624ac6de3f3255" id="r_a8a0d53746bdfac9e89624ac6de3f3255"><td class="memItemLeft" align="right" valign="top">std::span&lt; const size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a8a0d53746bdfac9e89624ac6de3f3255">at</a> (const std::size_t &amp;i_vertex) const</td></tr>
<tr class="memdesc:a8a0d53746bdfac9e89624ac6de3f3255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for access to a specified graph vertex's adjacency, with range checking.  <br /></td></tr>
<tr class="separator:a8a0d53746bdfac9e89624ac6de3f3255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497546e571b4c8faf508cc0a3821bf7e" id="r_a497546e571b4c8faf508cc0a3821bf7e"><td class="memItemLeft" align="right" valign="top">std::span&lt; const std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a497546e571b4c8faf508cc0a3821bf7e">operator[]</a> (const std::size_t &amp;i_vertex) const</td></tr>
<tr class="memdesc:a497546e571b4c8faf508cc0a3821bf7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for access to a specified graph vertex's adjacency.  <br /></td></tr>
<tr class="separator:a497546e571b4c8faf508cc0a3821bf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb9dc2d7a54d5a94828f752a3545eca" id="r_a6eb9dc2d7a54d5a94828f752a3545eca"><td class="memItemLeft" align="right" valign="top">std::span&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a6eb9dc2d7a54d5a94828f752a3545eca">operator[]</a> (const std::size_t &amp;i_vertex)</td></tr>
<tr class="memdesc:a6eb9dc2d7a54d5a94828f752a3545eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for access to a specified graph vertex's adjacency.  <br /></td></tr>
<tr class="separator:a6eb9dc2d7a54d5a94828f752a3545eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cefe8adda01a2b2120ba09e5c178952" id="r_a0cefe8adda01a2b2120ba09e5c178952"><td class="memItemLeft" align="right" valign="top">std::span&lt; const std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a0cefe8adda01a2b2120ba09e5c178952">front</a> () const</td></tr>
<tr class="memdesc:a0cefe8adda01a2b2120ba09e5c178952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first vertex's adjacency.  <br /></td></tr>
<tr class="separator:a0cefe8adda01a2b2120ba09e5c178952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d9fe4f431922d0e271393f03251789" id="r_ab4d9fe4f431922d0e271393f03251789"><td class="memItemLeft" align="right" valign="top">std::span&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#ab4d9fe4f431922d0e271393f03251789">front</a> ()</td></tr>
<tr class="memdesc:ab4d9fe4f431922d0e271393f03251789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first vertex's adjacency.  <br /></td></tr>
<tr class="separator:ab4d9fe4f431922d0e271393f03251789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4567bf20d54951808917d360ec756216" id="r_a4567bf20d54951808917d360ec756216"><td class="memItemLeft" align="right" valign="top">std::span&lt; const std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a4567bf20d54951808917d360ec756216">back</a> () const</td></tr>
<tr class="memdesc:a4567bf20d54951808917d360ec756216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last vertex's adjacency.  <br /></td></tr>
<tr class="separator:a4567bf20d54951808917d360ec756216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85513130d7fe4bbe632391024f07341e" id="r_a85513130d7fe4bbe632391024f07341e"><td class="memItemLeft" align="right" valign="top">std::span&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a85513130d7fe4bbe632391024f07341e">back</a> ()</td></tr>
<tr class="memdesc:a85513130d7fe4bbe632391024f07341e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last vertex's adjacency.  <br /></td></tr>
<tr class="separator:a85513130d7fe4bbe632391024f07341e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6351bcf6a11ab8eb13c14b30551f7b" id="r_a4b6351bcf6a11ab8eb13c14b30551f7b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::size_t *, std::size_t * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a4b6351bcf6a11ab8eb13c14b30551f7b">data</a> () noexcept</td></tr>
<tr class="memdesc:a4b6351bcf6a11ab8eb13c14b30551f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_disa_1_1_direct.html" title="Direct Dense Linear Solver Base Class.">Direct</a> access to the underlying vectors of the graph.  <br /></td></tr>
<tr class="separator:a4b6351bcf6a11ab8eb13c14b30551f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6fc5de06a318920d84f3c3742db07f" id="r_a3f6fc5de06a318920d84f3c3742db07f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a3f6fc5de06a318920d84f3c3742db07f">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a3f6fc5de06a318920d84f3c3742db07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the graph is empty.  <br /></td></tr>
<tr class="separator:a3f6fc5de06a318920d84f3c3742db07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6278cc8407882022d4790eadf867860c" id="r_a6278cc8407882022d4790eadf867860c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a6278cc8407882022d4790eadf867860c">size_vertex</a> () const noexcept</td></tr>
<tr class="memdesc:a6278cc8407882022d4790eadf867860c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices in the graph.  <br /></td></tr>
<tr class="separator:a6278cc8407882022d4790eadf867860c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13038ad8e3b198ec30c83e3ac524f2f" id="r_ae13038ad8e3b198ec30c83e3ac524f2f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#ae13038ad8e3b198ec30c83e3ac524f2f">size_edge</a> () const noexcept</td></tr>
<tr class="memdesc:ae13038ad8e3b198ec30c83e3ac524f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edge in the graph.  <br /></td></tr>
<tr class="separator:ae13038ad8e3b198ec30c83e3ac524f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c68d921ecb6dfdd73589aec1da59c4c" id="r_a2c68d921ecb6dfdd73589aec1da59c4c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a2c68d921ecb6dfdd73589aec1da59c4c">size</a> () const noexcept</td></tr>
<tr class="memdesc:a2c68d921ecb6dfdd73589aec1da59c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices and edges in the graph.  <br /></td></tr>
<tr class="separator:a2c68d921ecb6dfdd73589aec1da59c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaee28b4b5bc819b62e8a676b85f17a1" id="r_acaee28b4b5bc819b62e8a676b85f17a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#acaee28b4b5bc819b62e8a676b85f17a1">reserve</a> (std::size_t <a class="el" href="class_disa_1_1_adjacency___graph.html#a6278cc8407882022d4790eadf867860c">size_vertex</a>, std::size_t <a class="el" href="class_disa_1_1_adjacency___graph.html#ae13038ad8e3b198ec30c83e3ac524f2f">size_edge</a>=0) noexcept</td></tr>
<tr class="memdesc:acaee28b4b5bc819b62e8a676b85f17a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves enough memory such that the data structure can be filled with the parsed vertices and/or edges.  <br /></td></tr>
<tr class="separator:acaee28b4b5bc819b62e8a676b85f17a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2043042b56345027825344595df84c" id="r_ade2043042b56345027825344595df84c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#ade2043042b56345027825344595df84c">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:ade2043042b56345027825344595df84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of vertices and edges the graph has capacity (memory for).  <br /></td></tr>
<tr class="separator:ade2043042b56345027825344595df84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e4af5032d71179d3abf04db463f791" id="r_ad9e4af5032d71179d3abf04db463f791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#ad9e4af5032d71179d3abf04db463f791">shrink_to_fit</a> () noexcept</td></tr>
<tr class="memdesc:ad9e4af5032d71179d3abf04db463f791"><td class="mdescLeft">&#160;</td><td class="mdescRight">reduces memory usage of the graph by freeing unused memory for both vertices and edges.  <br /></td></tr>
<tr class="separator:ad9e4af5032d71179d3abf04db463f791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bfacfaaba9195e4498375659f43531" id="r_a03bfacfaaba9195e4498375659f43531"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a03bfacfaaba9195e4498375659f43531">clear</a> () noexcept</td></tr>
<tr class="memdesc:a03bfacfaaba9195e4498375659f43531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the contents of the graph, removing all vertices and edges.  <br /></td></tr>
<tr class="separator:a03bfacfaaba9195e4498375659f43531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08db0782bce16b125d8db05fd5d060ed" id="r_a08db0782bce16b125d8db05fd5d060ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a08db0782bce16b125d8db05fd5d060ed">insert</a> (const <a class="el" href="namespace_disa.html#a5d0458dbd92d3cbd94eddeb318b6d88f">Edge</a> &amp;edge)</td></tr>
<tr class="memdesc:a08db0782bce16b125d8db05fd5d060ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an edge into the graph, if the edges exists nothing occurs.  <br /></td></tr>
<tr class="separator:a08db0782bce16b125d8db05fd5d060ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afd7e3050e4addca0b428def0c02aba" id="r_a5afd7e3050e4addca0b428def0c02aba"><td class="memTemplParams" colspan="2">template&lt;class _unary_predicate &gt; </td></tr>
<tr class="memitem:a5afd7e3050e4addca0b428def0c02aba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a5afd7e3050e4addca0b428def0c02aba">erase_if</a> (_unary_predicate delete_vertex)</td></tr>
<tr class="memdesc:a5afd7e3050e4addca0b428def0c02aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase function, for deleting/erase multiple vertices at the same time.  <br /></td></tr>
<tr class="separator:a5afd7e3050e4addca0b428def0c02aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb75771fd0988bb4e6fa3c1dd5a1d3f" id="r_aecb75771fd0988bb4e6fa3c1dd5a1d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#aecb75771fd0988bb4e6fa3c1dd5a1d3f">resize</a> (const std::size_t &amp;<a class="el" href="class_disa_1_1_adjacency___graph.html#a2c68d921ecb6dfdd73589aec1da59c4c">size</a>)</td></tr>
<tr class="memdesc:aecb75771fd0988bb4e6fa3c1dd5a1d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the number of vertices in the graph.  <br /></td></tr>
<tr class="separator:aecb75771fd0988bb4e6fa3c1dd5a1d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082c64fd937c6c747b89c0c563b51528" id="r_a082c64fd937c6c747b89c0c563b51528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a082c64fd937c6c747b89c0c563b51528">swap</a> (<a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a> &amp;graph_other)</td></tr>
<tr class="memdesc:a082c64fd937c6c747b89c0c563b51528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the graph with the parsed graph.  <br /></td></tr>
<tr class="separator:a082c64fd937c6c747b89c0c563b51528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1995f33622008acb17fc118451503bdb" id="r_a1995f33622008acb17fc118451503bdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a1995f33622008acb17fc118451503bdb">contains</a> (const <a class="el" href="namespace_disa.html#a5d0458dbd92d3cbd94eddeb318b6d88f">Edge</a> &amp;edge) const</td></tr>
<tr class="memdesc:a1995f33622008acb17fc118451503bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the edge exists in the graph.  <br /></td></tr>
<tr class="separator:a1995f33622008acb17fc118451503bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdb4c97aeb4ab71d8b2929fb9399090" id="r_a7fdb4c97aeb4ab71d8b2929fb9399090"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a7fdb4c97aeb4ab71d8b2929fb9399090">degree</a> (const std::size_t &amp;i_vertex) const</td></tr>
<tr class="memdesc:a7fdb4c97aeb4ab71d8b2929fb9399090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the degree of a vertex: defined as the number of vertices it adjacent (connected) to.  <br /></td></tr>
<tr class="separator:a7fdb4c97aeb4ab71d8b2929fb9399090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908cc98dc8cb1a4d689ff9def67cffa7" id="r_a908cc98dc8cb1a4d689ff9def67cffa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a908cc98dc8cb1a4d689ff9def67cffa7">reorder</a> (const std::vector&lt; std::size_t &gt; &amp;permutation)</td></tr>
<tr class="memdesc:a908cc98dc8cb1a4d689ff9def67cffa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders this graph given a new index numbering.  <br /></td></tr>
<tr class="separator:a908cc98dc8cb1a4d689ff9def67cffa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae6f59b3c1be89303e2c3397bf1d47865" id="r_ae6f59b3c1be89303e2c3397bf1d47865"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;::iterator, std::vector&lt; std::size_t &gt;::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#ae6f59b3c1be89303e2c3397bf1d47865">vertex_adjacency_iter</a> (const std::size_t &amp;i_vertex)</td></tr>
<tr class="memdesc:ae6f59b3c1be89303e2c3397bf1d47865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterators to the beginning and end of a vertex adjacency graph.  <br /></td></tr>
<tr class="separator:ae6f59b3c1be89303e2c3397bf1d47865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719e65b36024dab62f4a5e05293721e6" id="r_a719e65b36024dab62f4a5e05293721e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a719e65b36024dab62f4a5e05293721e6">insert_vertex_adjacent_list</a> (std::size_t vertex, std::size_t insert_vertex)</td></tr>
<tr class="memdesc:a719e65b36024dab62f4a5e05293721e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts into the vertex adjacent list a new vertex in a sorted manner.  <br /></td></tr>
<tr class="separator:a719e65b36024dab62f4a5e05293721e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ada1d193b23e67a018ee5987607f93eb9" id="r_ada1d193b23e67a018ee5987607f93eb9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#ada1d193b23e67a018ee5987607f93eb9">vertex_adjacent_list</a></td></tr>
<tr class="memdesc:ada1d193b23e67a018ee5987607f93eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single contiguous list of all vertex adjacency for the graph.  <br /></td></tr>
<tr class="separator:ada1d193b23e67a018ee5987607f93eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a9ca141195563377732b946682cd7d" id="r_a42a9ca141195563377732b946682cd7d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html#a42a9ca141195563377732b946682cd7d">offset</a></td></tr>
<tr class="memdesc:a42a9ca141195563377732b946682cd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">List pointing to the start of each vertex's adjacency graph.  <br /></td></tr>
<tr class="separator:a42a9ca141195563377732b946682cd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;bool _directed&gt;<br />
class Disa::Adjacency_Graph&lt; _directed &gt;</div><p>An graph G(V, E), where V is a set of vertex indices and E is a set of undirected edges connecting the vertices in V. </p>
<p>An adjacency graph G stores a pair of integer sets, V and E. V represents a list of vertex/point/node labels and E contains a set (list) of pairs, each containing two unsigned integers which are elements of V. If V is an ordered continuous set of unsigned integers it can be represented implicitly. An edge E is said to be directed if the order of the pair matters, i.e. (i, j) != (j, i), else the edge is undirected. Note: in the undirected case the resulting graph is symmetric. This class thus represents G by storing the connectivity, of each vertex, to its connected neighbours (rather than the pairs of E directly). This allows for faster search times, similar to other 'sparse' containers.</p>
<p>From a design point of view this class is similar to that of a sparse vector, and thus follows most of the std::vector paradigms, except that each 'element' is dynamically sized and an ordered set of unsigned adjacency values.</p>
<dl class="section note"><dt>Note</dt><dd>:<ol type="1">
<li>Where _directed == false edges are undirected, and thus the edge (i, j) == (j, i).</li>
<li>Where _directed == true edges are undirected, and thus the edge (i, j) != (j, i).</li>
<li>Currently the graph does not support self connected edges i.e. edges for the form (i, i).</li>
<li>Once populated, no information about the edge indexing is stored.</li>
<li>The class assumes there is no difference between vertex types (red or blue colourings for example).</li>
<li>The class will assume that all vertices, with an index &lt;<a class="el" href="class_disa_1_1_adjacency___graph.html#a6278cc8407882022d4790eadf867860c" title="Returns the number of vertices in the graph.">size_vertex()</a> exist, independet of their connectivity.</li>
</ol>
</dd></dl>
<p>Future:</p><ol type="1">
<li>Look into optimising memory for directed graphs (in terms of max number of nodes, vs elements in adjacency list).</li>
<li>Add iterators, begin(), end() etc.</li>
<li>Create arithmetic operators +,-, etc for unions and intersections.</li>
<li>Possible base graph class from which this class can inherit. </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af42629b2ddf4987908b086887e3eff30" name="af42629b2ddf4987908b086887e3eff30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42629b2ddf4987908b086887e3eff30">&#9670;&#160;</a></span>Adjacency_Graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="ad0e925f4c74b5a028289f5e5a648a826" name="ad0e925f4c74b5a028289f5e5a648a826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e925f4c74b5a028289f5e5a648a826">&#9670;&#160;</a></span>Adjacency_Graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="namespace_disa.html#a5d0458dbd92d3cbd94eddeb318b6d88f">Edge</a> &gt;&#160;</td>
          <td class="paramname"><em>edge_graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construction via a list of edges connecting two vertices i and j, where i != j. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edge_graph</td><td>The list of edge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>At preset this is not writen efficiently, and can be improved, mainly used for testing.</dd></dl>
<p>Initializes an <a class="el" href="class_disa_1_1_adjacency___graph.html" title="An graph G(V, E), where V is a set of vertex indices and E is a set of undirected edges connecting th...">Adjacency_Graph</a> object with the edges in the given initializer list. The constructor finds the vertex with the highest index to determine a suitable reserve for the graph in the provided edge list. Each edge is then inserted into the edge and any excess reserve memory removed. </p>

</div>
</div>
<a id="afc378210b6ca44ccaddb93dd1faab93c" name="afc378210b6ca44ccaddb93dd1faab93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc378210b6ca44ccaddb93dd1faab93c">&#9670;&#160;</a></span>~Adjacency_Graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8a0d53746bdfac9e89624ac6de3f3255" name="a8a0d53746bdfac9e89624ac6de3f3255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0d53746bdfac9e89624ac6de3f3255">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; const size_t &gt; at </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for access to a specified graph vertex's adjacency, with range checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_vertex</td><td>The vertex index to the adjacency graph being sought. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A span of a single vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="a85513130d7fe4bbe632391024f07341e" name="a85513130d7fe4bbe632391024f07341e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85513130d7fe4bbe632391024f07341e">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; std::size_t &gt; back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last vertex's adjacency. </p>
<dl class="section return"><dt>Returns</dt><dd>A span of a the last vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="a4567bf20d54951808917d360ec756216" name="a4567bf20d54951808917d360ec756216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4567bf20d54951808917d360ec756216">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; const std::size_t &gt; back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last vertex's adjacency. </p>
<dl class="section return"><dt>Returns</dt><dd>A span of a the last vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="ade2043042b56345027825344595df84c" name="ade2043042b56345027825344595df84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2043042b56345027825344595df84c">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::size_t, std::size_t &gt; capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of vertices and edges the graph has capacity (memory for). </p>
<dl class="section return"><dt>Returns</dt><dd>Pair containing [vertices, edges]. </dd></dl>

</div>
</div>
<a id="a03bfacfaaba9195e4498375659f43531" name="a03bfacfaaba9195e4498375659f43531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bfacfaaba9195e4498375659f43531">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the contents of the graph, removing all vertices and edges. </p>

</div>
</div>
<a id="a1995f33622008acb17fc118451503bdb" name="a1995f33622008acb17fc118451503bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1995f33622008acb17fc118451503bdb">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a5d0458dbd92d3cbd94eddeb318b6d88f">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the edge exists in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The edge to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the graph contains the edge, else false.</dd></dl>
<p>First ensures that the vertex exists in the graph, then using std::ranges looks for the second vertex of the edge in the adjacency graph of the first. </p>

</div>
</div>
<a id="a4b6351bcf6a11ab8eb13c14b30551f7b" name="a4b6351bcf6a11ab8eb13c14b30551f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6351bcf6a11ab8eb13c14b30551f7b">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::size_t *, std::size_t * &gt; data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_disa_1_1_direct.html" title="Direct Dense Linear Solver Base Class.">Direct</a> access to the underlying vectors of the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>pair [pointer to vertex start, pointer to offset start].</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If empty all pointers returned pointers will be nullptrs. if the only the vertex list is empty a nullptr is returned for, while the pointer to the offset vector is returned. Finally populated pointers to both vectors are returned. </dd></dl>

</div>
</div>
<a id="a7fdb4c97aeb4ab71d8b2929fb9399090" name="a7fdb4c97aeb4ab71d8b2929fb9399090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdb4c97aeb4ab71d8b2929fb9399090">&#9670;&#160;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t degree </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the degree of a vertex: defined as the number of vertices it adjacent (connected) to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_vertex</td><td>The vertex index for which to compute the degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The degree of the vertex. </dd></dl>

</div>
</div>
<a id="a3f6fc5de06a318920d84f3c3742db07f" name="a3f6fc5de06a318920d84f3c3742db07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6fc5de06a318920d84f3c3742db07f">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the graph is empty. </p>
<p>An empty graph is considered where there are no vertices. </p><dl class="section return"><dt>Returns</dt><dd>True if the graph is empty, else false. </dd></dl>

</div>
</div>
<a id="a5afd7e3050e4addca0b428def0c02aba" name="a5afd7e3050e4addca0b428def0c02aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afd7e3050e4addca0b428def0c02aba">&#9670;&#160;</a></span>erase_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<div class="memtemplate">
template&lt;class _unary_predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void erase_if </td>
          <td>(</td>
          <td class="paramtype">_unary_predicate&#160;</td>
          <td class="paramname"><em>delete_vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase function, for deleting/erase multiple vertices at the same time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_unary_predicate</td><td>Should returns true if the element should be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delete_vertex</td><td>The instance of the _unary_predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can cause the graph to become disjoint.</dd></dl>
<p>Loops over the data and determines the new offsets and which entries in vertex adjacent list need to be removed, updating the offsets and recording the entries to be deleted. After which both the offset vector and the vertex adjacency list are 'looped' over and all entries flagged for removal are erased. Finally all vertices in the vertex adjacency list are relabeled. </p>

</div>
</div>
<a id="ab4d9fe4f431922d0e271393f03251789" name="ab4d9fe4f431922d0e271393f03251789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d9fe4f431922d0e271393f03251789">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; std::size_t &gt; front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first vertex's adjacency. </p>
<dl class="section return"><dt>Returns</dt><dd>A span of a the first vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="a0cefe8adda01a2b2120ba09e5c178952" name="a0cefe8adda01a2b2120ba09e5c178952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cefe8adda01a2b2120ba09e5c178952">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; const std::size_t &gt; front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first vertex's adjacency. </p>
<dl class="section return"><dt>Returns</dt><dd>A const span of a the first vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="a08db0782bce16b125d8db05fd5d060ed" name="a08db0782bce16b125d8db05fd5d060ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08db0782bce16b125d8db05fd5d060ed">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a5d0458dbd92d3cbd94eddeb318b6d88f">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an edge into the graph, if the edges exists nothing occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The edge to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an edge was inserted, else false.</dd></dl>
<p>If the edge is already in the graph the function returns immediately. If the edge contains a vertex index greater than the current graph size, the size of the graph is increased to accommodate the insertion. Lower bound is then used to insert the upper index of the edge into the lower index adjacency list. The offset values are then increased by one until the upper index is reached. The lower index is then inserted into the upper index adjacency list. Finally the offset values are increase by two till the end of the offset vector. </p>

</div>
</div>
<a id="a719e65b36024dab62f4a5e05293721e6" name="a719e65b36024dab62f4a5e05293721e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719e65b36024dab62f4a5e05293721e6">&#9670;&#160;</a></span>insert_vertex_adjacent_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void insert_vertex_adjacent_list </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>insert_vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts into the vertex adjacent list a new vertex in a sorted manner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The vertex to have its adjacency updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insert_vertex</td><td>The new vertex index to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation breaks the graph if not used correctly, as the offsets are not updated. Further, if the offset vector is not upto date this operation produces undefined behaviour.</dd></dl>
<p>This function inserts a new vertex into the adjacency list of the specified vertex in the graph. If the inserted vertex is already present in the adjacency list, this function does nothing. </p>

</div>
</div>
<a id="a6eb9dc2d7a54d5a94828f752a3545eca" name="a6eb9dc2d7a54d5a94828f752a3545eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb9dc2d7a54d5a94828f752a3545eca">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; std::size_t &gt; operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for access to a specified graph vertex's adjacency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_vertex</td><td>The vertex index to the adjacency graph being sought. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A span of a single vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="a497546e571b4c8faf508cc0a3821bf7e" name="a497546e571b4c8faf508cc0a3821bf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497546e571b4c8faf508cc0a3821bf7e">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; const std::size_t &gt; operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for access to a specified graph vertex's adjacency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_vertex</td><td>The vertex index to the adjacency graph being sought. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A span of a single vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="a908cc98dc8cb1a4d689ff9def67cffa7" name="a908cc98dc8cb1a4d689ff9def67cffa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908cc98dc8cb1a4d689ff9def67cffa7">&#9670;&#160;</a></span>reorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; _directed &gt; reorder </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders this graph given a new index numbering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">permutation</td><td>The permutation vector, mapping new_index = permutation[old_index]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old, un-permuted, adjacency graph.</dd></dl>
<p>To begin new memory is allocated for a new graph. First the offsets for the new graph of determined by computing and storing the offset for each old vertex and storing it in the new vertex position, and then by summing the preceding offsets to obtain the new offset for each vertex. The new vertex lists are populated by coping and renumbering the old vertex list's data to the new positions, using both the permutation vector and the newly computed offsets. Each must also be resorted in an ascending fashion. Finally, the new graph is swapped with the current and returned. </p>

</div>
</div>
<a id="acaee28b4b5bc819b62e8a676b85f17a1" name="acaee28b4b5bc819b62e8a676b85f17a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaee28b4b5bc819b62e8a676b85f17a1">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_edge</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves enough memory such that the data structure can be filled with the parsed vertices and/or edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size_vertex</td><td>The total number of vertices to reserve for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_edge</td><td>The total number of edge to reserve for (defaults to zero). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecb75771fd0988bb4e6fa3c1dd5a1d3f" name="aecb75771fd0988bb4e6fa3c1dd5a1d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb75771fd0988bb4e6fa3c1dd5a1d3f">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void resize </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the number of vertices in the graph. </p>
<p>@size[in] The number of vertices to resize the graph to.</p>
<dl class="section note"><dt>Note</dt><dd>Edges are removed if the graph size is reduced.</dd></dl>
<p>Resizes the graph. If the graph is smaller than the new size the offset list is grown out, essentially representing the addition of a disconnected point cloud. If the size is, however, smaller than the current size of the graph the vertices with an index greater or equal to the new size are removed. The 'edges' connecting the removed vertices from the remaining vertices are sought and removed from the graph. </p>

</div>
</div>
<a id="ad9e4af5032d71179d3abf04db463f791" name="ad9e4af5032d71179d3abf04db463f791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e4af5032d71179d3abf04db463f791">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reduces memory usage of the graph by freeing unused memory for both vertices and edges. </p>

</div>
</div>
<a id="a2c68d921ecb6dfdd73589aec1da59c4c" name="a2c68d921ecb6dfdd73589aec1da59c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c68d921ecb6dfdd73589aec1da59c4c">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::size_t, std::size_t &gt; size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of vertices and edges in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>Pair containing [vertices, edges]. </dd></dl>

</div>
</div>
<a id="ae13038ad8e3b198ec30c83e3ac524f2f" name="ae13038ad8e3b198ec30c83e3ac524f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13038ad8e3b198ec30c83e3ac524f2f">&#9670;&#160;</a></span>size_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t size_edge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of edge in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of edge. </dd></dl>

</div>
</div>
<a id="a6278cc8407882022d4790eadf867860c" name="a6278cc8407882022d4790eadf867860c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6278cc8407882022d4790eadf867860c">&#9670;&#160;</a></span>size_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t size_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of vertices in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices. </dd></dl>

</div>
</div>
<a id="a082c64fd937c6c747b89c0c563b51528" name="a082c64fd937c6c747b89c0c563b51528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082c64fd937c6c747b89c0c563b51528">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; _directed &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the graph with the parsed graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">graph_other</td><td>The other graph, this graph will obtain the other's vertices and edges, and visa versa. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6f59b3c1be89303e2c3397bf1d47865" name="ae6f59b3c1be89303e2c3397bf1d47865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f59b3c1be89303e2c3397bf1d47865">&#9670;&#160;</a></span>vertex_adjacency_iter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;::iterator, std::vector&lt; std::size_t &gt;::iterator &gt; vertex_adjacency_iter </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterators to the beginning and end of a vertex adjacency graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_vertex</td><td>The vertex index to the adjacency graph being sought. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of iterators, [beginning of the vertex adjacency graph, end of the vertex adjacency graph]. </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a42a9ca141195563377732b946682cd7d" name="a42a9ca141195563377732b946682cd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a9ca141195563377732b946682cd7d">&#9670;&#160;</a></span>offset</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List pointing to the start of each vertex's adjacency graph. </p>

</div>
</div>
<a id="ada1d193b23e67a018ee5987607f93eb9" name="ada1d193b23e67a018ee5987607f93eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1d193b23e67a018ee5987607f93eb9">&#9670;&#160;</a></span>vertex_adjacent_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool _directed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; vertex_adjacent_list</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Single contiguous list of all vertex adjacency for the graph. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/graph/<a class="el" href="adjacency__graph_8hpp_source.html">adjacency_graph.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_disa.html">Disa</a></li><li class="navelem"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
