<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Disa: Disa Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Disa
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_disa.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Disa Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mathematical matrix, of dimension _row x _col, where every matrix element has allocated has memory.  <a href="struct_disa_1_1_matrix___dense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_matrix___dense_3_01__type_00_010_00_010_01_4.html">Matrix_Dense&lt; _type, 0, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mathematical matrix, of dimension _row x _col, where every matrix element has allocated has memory.  <a href="struct_disa_1_1_matrix___dense_3_01__type_00_010_00_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_matrix___static___demoter.html">Matrix_Static_Demoter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for matrix multiplication, where the static nature of matrices must decay to dynamic.  <a href="struct_disa_1_1_matrix___static___demoter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_matrix___sparse___row.html">Matrix_Sparse_Row</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class, enables column iteration support.  <a href="class_disa_1_1_matrix___sparse___row.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_iterator___matrix___sparse___row.html">Iterator_Matrix_Sparse_Row</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to advance over rows of a CSR sparse matrix.  <a href="struct_disa_1_1_iterator___matrix___sparse___row.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_iterator___matrix___sparse___element.html">Iterator_Matrix_Sparse_Element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to advance over elements of a row of a CSR sparse matrix.  <a href="struct_disa_1_1_iterator___matrix___sparse___element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A efficient data structure which represents a matrix comprised of mostly zero entries.  <a href="class_disa_1_1_matrix___sparse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mathematical Vector, of dimension _size, where every vector element has allocated has memory.  <a href="struct_disa_1_1_vector___dense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_vector___dense_3_01__type_00_010_01_4.html">Vector_Dense&lt; _type, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses, between two vectors, the static vector type if possible.  <a href="struct_disa_1_1_static___promoter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_static___demoter.html">Static_Demoter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses, between two vectors, the dynamic vector type if possible.  <a href="struct_disa_1_1_static___demoter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An graph G(V, E), where V is a set of vertex indices and E is a set of undirected edges connecting the vertices in V.  <a href="class_disa_1_1_adjacency___graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_direct.html">Direct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_disa_1_1_direct.html" title="Direct Dense Linear Solver Base Class.">Direct</a> Dense Linear <a class="el" href="class_disa_1_1_solver.html" title="Solver.">Solver</a> Base Class.  <a href="class_disa_1_1_direct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_direct___lower___upper___factorisation.html">Direct_Lower_Upper_Factorisation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Lower Upper Factorisation Linear <a class="el" href="class_disa_1_1_solver.html" title="Solver.">Solver</a> for dense linear systems.  <a href="class_disa_1_1_direct___lower___upper___factorisation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_solver.html">Solver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_disa_1_1_solver.html" title="Solver.">Solver</a>.  <a href="class_disa_1_1_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_solver___fixed___point___data.html">Solver_Fixed_Point_Data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_solver___fixed___point___jacobi___data.html">Solver_Fixed_Point_Jacobi_Data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_solver___fixed___point___sor___data.html">Solver_Fixed_Point_Sor_Data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_solver___fixed___point.html">Solver_Fixed_Point</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_solver___data.html">Solver_Data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_solver___iterative.html">Solver_Iterative</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_solver___config.html">Solver_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all possible configurations for all solvers in <a class="el" href="namespace_disa.html">Disa</a>.  <a href="struct_disa_1_1_solver___config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_convergence___data.html">Convergence_Data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains data to track the convergence progress of a solver.  <a href="struct_disa_1_1_convergence___data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_disa_1_1_convergence___criteria.html">Convergence_Criteria</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the criteria values against which convergence status can be assessed.  <a href="struct_disa_1_1_convergence___criteria.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a292ef5870b9a88a0657959d670390c41"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a292ef5870b9a88a0657959d670390c41">s_size_t</a> = std::make_signed&lt; std::size_t &gt;::type</td></tr>
<tr class="memdesc:a292ef5870b9a88a0657959d670390c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for static casting where needed, and to prevent compile warnings (if you are using a signed type for size_t, you are doing something wrong).  <a href="namespace_disa.html#a292ef5870b9a88a0657959d670390c41">More...</a><br /></td></tr>
<tr class="separator:a292ef5870b9a88a0657959d670390c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2981f3f834be9448a6ab06c28748eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> = double</td></tr>
<tr class="separator:a8c2981f3f834be9448a6ab06c28748eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0458dbd92d3cbd94eddeb318b6d88f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a5d0458dbd92d3cbd94eddeb318b6d88f">Edge</a> = std::pair&lt; std::size_t, std::size_t &gt;</td></tr>
<tr class="separator:a5d0458dbd92d3cbd94eddeb318b6d88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2a6b61cf124143cb8befeabf5d2f38"><td class="memTemplParams" colspan="2">template&lt;std::size_t _size&gt; </td></tr>
<tr class="memitem:a1b2a6b61cf124143cb8befeabf5d2f38"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a1b2a6b61cf124143cb8befeabf5d2f38">Solver_LUP</a> = <a class="el" href="class_disa_1_1_direct___lower___upper___factorisation.html">Direct_Lower_Upper_Factorisation</a>&lt; <a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987ba8742060c1cb1135de58ec175157374f8">Solver_Type::lower_upper_factorisation</a>, _size, true &gt;</td></tr>
<tr class="separator:a1b2a6b61cf124143cb8befeabf5d2f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516103eb569d14a1941f8c15d3ce108a"><td class="memTemplParams" colspan="2">template&lt;std::size_t _size&gt; </td></tr>
<tr class="memitem:a516103eb569d14a1941f8c15d3ce108a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a516103eb569d14a1941f8c15d3ce108a">Solver_LU</a> = <a class="el" href="class_disa_1_1_direct___lower___upper___factorisation.html">Direct_Lower_Upper_Factorisation</a>&lt; <a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987ba8742060c1cb1135de58ec175157374f8">Solver_Type::lower_upper_factorisation</a>, _size, false &gt;</td></tr>
<tr class="separator:a516103eb569d14a1941f8c15d3ce108a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0db03cf0bcf32b769d6b5adb2bb0b7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_disa_1_1_solver___fixed___point.html">Solver_Fixed_Point</a>&lt; <a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987ba1606457c201437c4f914a83939e25722">Solver_Type::jacobi</a>, <a class="el" href="struct_disa_1_1_solver___fixed___point___jacobi___data.html">Solver_Fixed_Point_Jacobi_Data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#aad0db03cf0bcf32b769d6b5adb2bb0b7">Solver_Jacobi</a></td></tr>
<tr class="separator:aad0db03cf0bcf32b769d6b5adb2bb0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398ac024b656d2e99d3f07e22b7d4d5e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_disa_1_1_solver___fixed___point.html">Solver_Fixed_Point</a>&lt; <a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987bacd9152dc4c50cce6f3cab9c7bfe58c4f">Solver_Type::gauss_seidel</a>, <a class="el" href="struct_disa_1_1_solver___fixed___point___data.html">Solver_Fixed_Point_Data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a398ac024b656d2e99d3f07e22b7d4d5e">Solver_Gauss_Seidel</a></td></tr>
<tr class="separator:a398ac024b656d2e99d3f07e22b7d4d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc152cbbb1cc37d652c24e622489b50a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_disa_1_1_solver___fixed___point.html">Solver_Fixed_Point</a>&lt; <a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987bab3a4458f26ca796419728e53b8c9c79d">Solver_Type::successive_over_relaxation</a>, <a class="el" href="struct_disa_1_1_solver___fixed___point___sor___data.html">Solver_Fixed_Point_Sor_Data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#abc152cbbb1cc37d652c24e622489b50a">Sover_Sor</a></td></tr>
<tr class="separator:abc152cbbb1cc37d652c24e622489b50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6ad351ea7d2afe4c8726f1e0fd6a0b0e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a6ad351ea7d2afe4c8726f1e0fd6a0b0e">Log_Level</a> : uint8_t { <a class="el" href="namespace_disa.html#a6ad351ea7d2afe4c8726f1e0fd6a0b0ea902b0d55fddef6f8d651fe1035b7d4bd">Error</a>
, <a class="el" href="namespace_disa.html#a6ad351ea7d2afe4c8726f1e0fd6a0b0ea0eaadb4fcb48a0a0ed7bc9868be9fbaa">Warning</a>
, <a class="el" href="namespace_disa.html#a6ad351ea7d2afe4c8726f1e0fd6a0b0ea4059b0251f66a18cb56f544728796875">Info</a>
, <a class="el" href="namespace_disa.html#a6ad351ea7d2afe4c8726f1e0fd6a0b0eaa603905470e2a5b8c13e96b579ef0dba">Debug</a>
 }</td></tr>
<tr class="memdesc:a6ad351ea7d2afe4c8726f1e0fd6a0b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logging Level, used to defines the severity of messages to the console.  <a href="namespace_disa.html#a6ad351ea7d2afe4c8726f1e0fd6a0b0e">More...</a><br /></td></tr>
<tr class="separator:a6ad351ea7d2afe4c8726f1e0fd6a0b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc27b15a9dee0ad91cc0f746fcd987b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987b">Solver_Type</a> { <br />
&#160;&#160;<a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987ba8742060c1cb1135de58ec175157374f8">lower_upper_factorisation</a>
, <a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987ba1606457c201437c4f914a83939e25722">jacobi</a>
, <a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987bacd9152dc4c50cce6f3cab9c7bfe58c4f">gauss_seidel</a>
, <a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987bab3a4458f26ca796419728e53b8c9c79d">successive_over_relaxation</a>
, <br />
&#160;&#160;<a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987baad921d60486366258809553a3db49a4a">unknown</a>
<br />
 }</td></tr>
<tr class="memdesc:a5cc27b15a9dee0ad91cc0f746fcd987b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated list of all linear solvers in <a class="el" href="namespace_disa.html">Disa</a>.  <a href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987b">More...</a><br /></td></tr>
<tr class="separator:a5cc27b15a9dee0ad91cc0f746fcd987b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac66f762a69bdf0037319671a4d853cc8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#ac66f762a69bdf0037319671a4d853cc8">operator&lt;&lt;</a> (std::ostream &amp;ostream, const <a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a> &amp;graph)</td></tr>
<tr class="memdesc:ac66f762a69bdf0037319671a4d853cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded stream operator for the out stream, writes out a formatted graph.  <a href="namespace_disa.html#ac66f762a69bdf0037319671a4d853cc8">More...</a><br /></td></tr>
<tr class="separator:ac66f762a69bdf0037319671a4d853cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7ebf3a6a58690fea1530419eeac71c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#abd7ebf3a6a58690fea1530419eeac71c">multinode_level_set_expansion</a> (const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt; &amp;graph, std::size_t max_iter, std::vector&lt; <a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a> &gt; &amp;subgraph_list)</td></tr>
<tr class="memdesc:abd7ebf3a6a58690fea1530419eeac71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs level set expansion on subgraphs to partition a graph, requires an initial partitioning.  <a href="namespace_disa.html#abd7ebf3a6a58690fea1530419eeac71c">More...</a><br /></td></tr>
<tr class="separator:abd7ebf3a6a58690fea1530419eeac71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccfdf59250250b0a6e5d66cea34909d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a9ccfdf59250250b0a6e5d66cea34909d">recursive_graph_bisection</a> (const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt; &amp;graph, std::size_t number_partitions)</td></tr>
<tr class="memdesc:a9ccfdf59250250b0a6e5d66cea34909d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively bisects a given graph into a specified number of subgraphs.  <a href="namespace_disa.html#a9ccfdf59250250b0a6e5d66cea34909d">More...</a><br /></td></tr>
<tr class="separator:a9ccfdf59250250b0a6e5d66cea34909d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf04b38f6a4f93b737ffb6ac2b433224"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#acf04b38f6a4f93b737ffb6ac2b433224">breadth_first</a> (const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt; &amp;graph, std::size_t start_vertex=0)</td></tr>
<tr class="memdesc:acf04b38f6a4f93b737ffb6ac2b433224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a permutation vector for a given non-disjoint graph using the bread first (search) algorithm.  <a href="namespace_disa.html#acf04b38f6a4f93b737ffb6ac2b433224">More...</a><br /></td></tr>
<tr class="separator:acf04b38f6a4f93b737ffb6ac2b433224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cb4eaebee2a4bfcc4350470a586274"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a07cb4eaebee2a4bfcc4350470a586274">cuthill_mckee</a> (const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt; &amp;graph, std::size_t start_vertex=std::numeric_limits&lt; std::size_t &gt;::max())</td></tr>
<tr class="memdesc:a07cb4eaebee2a4bfcc4350470a586274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a permutation vector given non-disjoint graph using the Cuthill-Mckee algorithm.  <a href="namespace_disa.html#a07cb4eaebee2a4bfcc4350470a586274">More...</a><br /></td></tr>
<tr class="separator:a07cb4eaebee2a4bfcc4350470a586274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb0d3be9790d345b48e09008ac179f0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a5fb0d3be9790d345b48e09008ac179f0">greedy_multicolouring</a> (const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt; &amp;graph)</td></tr>
<tr class="memdesc:a5fb0d3be9790d345b48e09008ac179f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a permutation vector given non-disjoint graph using a multicolouring algorithm.  <a href="namespace_disa.html#a5fb0d3be9790d345b48e09008ac179f0">More...</a><br /></td></tr>
<tr class="separator:a5fb0d3be9790d345b48e09008ac179f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb94f81769534f4e368f72f9f7c2721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_disa_1_1_solver.html">Solver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#aefb94f81769534f4e368f72f9f7c2721">build_solver</a> (<a class="el" href="struct_disa_1_1_solver___config.html">Solver_Config</a> config)</td></tr>
<tr class="separator:aefb94f81769534f4e368f72f9f7c2721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6deefe8e3aefb6e6e2699e3d6751aad6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a6deefe8e3aefb6e6e2699e3d6751aad6">forward_sweep</a> (const <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;a_matrix, const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, 0 &gt; &amp;x_vector, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, 0 &gt; &amp;x_update, const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, 0 &gt; &amp;b_vector, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> omega=1)</td></tr>
<tr class="separator:a6deefe8e3aefb6e6e2699e3d6751aad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523c6673ab5cddb1961a16af22f8e95f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a523c6673ab5cddb1961a16af22f8e95f">backward_sweep</a> (const <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;a_matrix, const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, 0 &gt; &amp;x_vector, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, 0 &gt; &amp;x_update, const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, 0 &gt; &amp;b_vector, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> omega=1)</td></tr>
<tr class="separator:a523c6673ab5cddb1961a16af22f8e95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313943c669dbb0d1eff816585b62c881"><td class="memItemLeft" align="right" valign="top">std::basic_string&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a313943c669dbb0d1eff816585b62c881">console_format</a> (const <a class="el" href="namespace_disa.html#a6ad351ea7d2afe4c8726f1e0fd6a0b0e">Log_Level</a> level, const std::source_location &amp;location)</td></tr>
<tr class="memdesc:a313943c669dbb0d1eff816585b62c881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds additional information to messages about to be printed to screen, such as file and line numbers.  <a href="namespace_disa.html#a313943c669dbb0d1eff816585b62c881">More...</a><br /></td></tr>
<tr class="separator:a313943c669dbb0d1eff816585b62c881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3907d6a33ce44e218aa2e45651d6cc02"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _row, std::size_t _col&gt; </td></tr>
<tr class="memitem:a3907d6a33ce44e218aa2e45651d6cc02"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row, _col &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a3907d6a33ce44e218aa2e45651d6cc02">operator*</a> (const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar, <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row, _col &gt; matrix)</td></tr>
<tr class="memdesc:a3907d6a33ce44e218aa2e45651d6cc02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a matrix by a scalar, C = b*A, where A, and C are matrices and b is a scalar.  <a href="namespace_disa.html#a3907d6a33ce44e218aa2e45651d6cc02">More...</a><br /></td></tr>
<tr class="separator:a3907d6a33ce44e218aa2e45651d6cc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1013b883de71a12d538bd2ec65989b5f"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _row, std::size_t _col&gt; </td></tr>
<tr class="memitem:a1013b883de71a12d538bd2ec65989b5f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row, _col &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a1013b883de71a12d538bd2ec65989b5f">operator/</a> (<a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row, _col &gt; matrix, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar)</td></tr>
<tr class="memdesc:a1013b883de71a12d538bd2ec65989b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides a matrix by a scalar, C = A/b, where A, and C are matrices and b is a scalar.  <a href="namespace_disa.html#a1013b883de71a12d538bd2ec65989b5f">More...</a><br /></td></tr>
<tr class="separator:a1013b883de71a12d538bd2ec65989b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c8e0d311dc2db38732db8d7362a01e"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _row, std::size_t _col, std::size_t _size&gt; </td></tr>
<tr class="memitem:ae4c8e0d311dc2db38732db8d7362a01e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt; <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _row &gt;, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#ae4c8e0d311dc2db38732db8d7362a01e">operator*</a> (const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row, _col &gt; &amp;matrix, const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt; &amp;vector)</td></tr>
<tr class="memdesc:ae4c8e0d311dc2db38732db8d7362a01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a matrix and vector, c = A*b, where A is a matrix and c and b are vectors.  <a href="namespace_disa.html#ae4c8e0d311dc2db38732db8d7362a01e">More...</a><br /></td></tr>
<tr class="separator:ae4c8e0d311dc2db38732db8d7362a01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd877c06bd6db306d864f4f64ef274ea"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _row_0, std::size_t _col_0, std::size_t _row_1, std::size_t _col_1&gt; </td></tr>
<tr class="memitem:acd877c06bd6db306d864f4f64ef274ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt; <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_0, _col_0 &gt;, <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_1, _col_1 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#acd877c06bd6db306d864f4f64ef274ea">operator+</a> (const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_0, _col_0 &gt; &amp;matrix_0, const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_1, _col_1 &gt; &amp;matrix_1)</td></tr>
<tr class="memdesc:acd877c06bd6db306d864f4f64ef274ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two matrices together, C = A + B, where A, B, and C are matrices.  <a href="namespace_disa.html#acd877c06bd6db306d864f4f64ef274ea">More...</a><br /></td></tr>
<tr class="separator:acd877c06bd6db306d864f4f64ef274ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9e590e3eb5fa801628482978f4abd7"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _row_0, std::size_t _col_0, std::size_t _row_1, std::size_t _col_1&gt; </td></tr>
<tr class="memitem:ace9e590e3eb5fa801628482978f4abd7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt; <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_0, _col_0 &gt;, <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_1, _col_1 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#ace9e590e3eb5fa801628482978f4abd7">operator-</a> (const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_0, _col_0 &gt; &amp;matrix_0, const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_1, _col_1 &gt; &amp;matrix_1)</td></tr>
<tr class="memdesc:ace9e590e3eb5fa801628482978f4abd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts one matrix from another, C = A - B, where A, B, and C are matrices.  <a href="namespace_disa.html#ace9e590e3eb5fa801628482978f4abd7">More...</a><br /></td></tr>
<tr class="separator:ace9e590e3eb5fa801628482978f4abd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73672d307ce64b3565cddc5da2a92cf"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _row_0, std::size_t _col_0, std::size_t _row_1, std::size_t _col_1&gt; </td></tr>
<tr class="memitem:aa73672d307ce64b3565cddc5da2a92cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_disa_1_1_matrix___static___demoter.html">Matrix_Static_Demoter</a>&lt; const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_0, _col_0 &gt;, const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_1, _col_1 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#aa73672d307ce64b3565cddc5da2a92cf">operator*</a> (const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_0, _col_0 &gt; &amp;matrix_0, const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_1, _col_1 &gt; &amp;matrix_1)</td></tr>
<tr class="memdesc:aa73672d307ce64b3565cddc5da2a92cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiples two matrices together, C = A*B, where A, B, and C are matrices.  <a href="namespace_disa.html#aa73672d307ce64b3565cddc5da2a92cf">More...</a><br /></td></tr>
<tr class="separator:aa73672d307ce64b3565cddc5da2a92cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af509d324b0288be3dd64abb559e35e23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#af509d324b0288be3dd64abb559e35e23">operator*</a> (const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar, <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> matrix)</td></tr>
<tr class="memdesc:af509d324b0288be3dd64abb559e35e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a sparse matrix by a scalar, C = b*A, where A, and C are matrices and b is a scalar.  <a href="namespace_disa.html#af509d324b0288be3dd64abb559e35e23">More...</a><br /></td></tr>
<tr class="separator:af509d324b0288be3dd64abb559e35e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d366a4065a104d047950a627bad4c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a6d366a4065a104d047950a627bad4c33">operator/</a> (<a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> matrix, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar)</td></tr>
<tr class="memdesc:a6d366a4065a104d047950a627bad4c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides a sparse matrix by a scalar, C = A/b, where A, and C are sparse matrices and b is a scalar.  <a href="namespace_disa.html#a6d366a4065a104d047950a627bad4c33">More...</a><br /></td></tr>
<tr class="separator:a6d366a4065a104d047950a627bad4c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bad92e4006dd16d1ac6b6149e647ff4"><td class="memTemplParams" colspan="2">template&lt;std::size_t _size&gt; </td></tr>
<tr class="memitem:a8bad92e4006dd16d1ac6b6149e647ff4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, _size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a8bad92e4006dd16d1ac6b6149e647ff4">operator*</a> (const <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;matrix, const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, _size &gt; &amp;vector)</td></tr>
<tr class="memdesc:a8bad92e4006dd16d1ac6b6149e647ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a sparse matrix and vector, c = A*b, where A is a sparse matrix and c and b are vectors.  <a href="namespace_disa.html#a8bad92e4006dd16d1ac6b6149e647ff4">More...</a><br /></td></tr>
<tr class="separator:a8bad92e4006dd16d1ac6b6149e647ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff24d51f9c4906a5d5a6cc8c4f4879b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#aff24d51f9c4906a5d5a6cc8c4f4879b8">operator+</a> (<a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> matrix_0, const <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;matrix_1)</td></tr>
<tr class="memdesc:aff24d51f9c4906a5d5a6cc8c4f4879b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two sparse matrices together, C = A + B, where A, B, and C are sparse matrices.  <a href="namespace_disa.html#aff24d51f9c4906a5d5a6cc8c4f4879b8">More...</a><br /></td></tr>
<tr class="separator:aff24d51f9c4906a5d5a6cc8c4f4879b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b5088e0d1932d3bf48f2186cbc59c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a73b5088e0d1932d3bf48f2186cbc59c5">operator-</a> (<a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> matrix_0, const <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;matrix_1)</td></tr>
<tr class="memdesc:a73b5088e0d1932d3bf48f2186cbc59c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts one sparse matrix from another, C = A - B, where A, B, and C are sparse matrices.  <a href="namespace_disa.html#a73b5088e0d1932d3bf48f2186cbc59c5">More...</a><br /></td></tr>
<tr class="separator:a73b5088e0d1932d3bf48f2186cbc59c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef2ba6a0c7cefc2c527b386d901ed2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a4ef2ba6a0c7cefc2c527b386d901ed2e">operator*</a> (<a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> matrix_0, const <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;matrix_1)</td></tr>
<tr class="memdesc:a4ef2ba6a0c7cefc2c527b386d901ed2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiples two sparse matrices together, C = A*B, where A, B, and C are sparse matrices.  <a href="namespace_disa.html#a4ef2ba6a0c7cefc2c527b386d901ed2e">More...</a><br /></td></tr>
<tr class="separator:a4ef2ba6a0c7cefc2c527b386d901ed2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9ac18476d94a7fb07a8ccbcd276327"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#abc9ac18476d94a7fb07a8ccbcd276327">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;matrix)</td></tr>
<tr class="memdesc:abc9ac18476d94a7fb07a8ccbcd276327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output shift operator - to write to console.  <a href="namespace_disa.html#abc9ac18476d94a7fb07a8ccbcd276327">More...</a><br /></td></tr>
<tr class="separator:abc9ac18476d94a7fb07a8ccbcd276327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2e6c44ba8374882573d628b743271d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a4a2e6c44ba8374882573d628b743271d">is_nearly_equal</a> (const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar_0, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar_1, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;tolerance_relative=<a class="el" href="namespace_disa.html#acbf188d2f52238f11ae72c35ff61d996">default_relative</a>, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;tolerance_absolute=<a class="el" href="namespace_disa.html#a0f0e38acec7e979eee6eaddf423d93b7">default_absolute</a>)</td></tr>
<tr class="memdesc:a4a2e6c44ba8374882573d628b743271d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two scalars are 'almost' equal to each other, using tolerancing.  <a href="namespace_disa.html#a4a2e6c44ba8374882573d628b743271d">More...</a><br /></td></tr>
<tr class="separator:a4a2e6c44ba8374882573d628b743271d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79b4c22b2251a16b4ce10ab35754083"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#ac79b4c22b2251a16b4ce10ab35754083">is_nearly_greater_equal</a> (const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar_0, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar_1, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;tolerance_relative=<a class="el" href="namespace_disa.html#acbf188d2f52238f11ae72c35ff61d996">default_relative</a>, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;tolerance_absolute=<a class="el" href="namespace_disa.html#a0f0e38acec7e979eee6eaddf423d93b7">default_absolute</a>)</td></tr>
<tr class="memdesc:ac79b4c22b2251a16b4ce10ab35754083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a first scalar is greater than or nearly equal to a second, could be though of as operator&gt;=~.  <a href="namespace_disa.html#ac79b4c22b2251a16b4ce10ab35754083">More...</a><br /></td></tr>
<tr class="separator:ac79b4c22b2251a16b4ce10ab35754083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169f81a587880e04bd2bab802b3de310"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a169f81a587880e04bd2bab802b3de310">is_nearly_less_equal</a> (const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar_0, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar_1, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;tolerance_relative=<a class="el" href="namespace_disa.html#acbf188d2f52238f11ae72c35ff61d996">default_relative</a>, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;tolerance_absolute=<a class="el" href="namespace_disa.html#a0f0e38acec7e979eee6eaddf423d93b7">default_absolute</a>)</td></tr>
<tr class="memdesc:a169f81a587880e04bd2bab802b3de310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a first scalar is less than or nearly equal to a second, could be though of as operator&lt;=~.  <a href="namespace_disa.html#a169f81a587880e04bd2bab802b3de310">More...</a><br /></td></tr>
<tr class="separator:a169f81a587880e04bd2bab802b3de310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa779399caa791454283aac3a9627a869"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#aa779399caa791454283aac3a9627a869">is_nearly_greater</a> (const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar_0, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar_1, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;tolerance_relative=<a class="el" href="namespace_disa.html#acbf188d2f52238f11ae72c35ff61d996">default_relative</a>, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;tolerance_absolute=<a class="el" href="namespace_disa.html#a0f0e38acec7e979eee6eaddf423d93b7">default_absolute</a>)</td></tr>
<tr class="memdesc:aa779399caa791454283aac3a9627a869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a first scalar is not less than or nearly equal to a second, could be though of as operator&gt;~.  <a href="namespace_disa.html#aa779399caa791454283aac3a9627a869">More...</a><br /></td></tr>
<tr class="separator:aa779399caa791454283aac3a9627a869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30c55fc1693e9407d06d204a86b28aa"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#ac30c55fc1693e9407d06d204a86b28aa">is_nearly_less</a> (const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar_0, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;scalar_1, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;tolerance_relative=<a class="el" href="namespace_disa.html#acbf188d2f52238f11ae72c35ff61d996">default_relative</a>, const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;tolerance_absolute=<a class="el" href="namespace_disa.html#a0f0e38acec7e979eee6eaddf423d93b7">default_absolute</a>)</td></tr>
<tr class="memdesc:ac30c55fc1693e9407d06d204a86b28aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a first scalar is not greater than or nearly equal to a second, could be though of as operator&lt;~.  <a href="namespace_disa.html#ac30c55fc1693e9407d06d204a86b28aa">More...</a><br /></td></tr>
<tr class="separator:ac30c55fc1693e9407d06d204a86b28aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6a836107e9306bad16bfde83210c29"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _size&gt; </td></tr>
<tr class="memitem:ada6a836107e9306bad16bfde83210c29"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#ada6a836107e9306bad16bfde83210c29">operator*</a> (const _type &amp;scalar, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt; vector)</td></tr>
<tr class="memdesc:ada6a836107e9306bad16bfde83210c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a vector by a scalar, c = b*a, where a, and c are vectors and b is a scalar.  <a href="namespace_disa.html#ada6a836107e9306bad16bfde83210c29">More...</a><br /></td></tr>
<tr class="separator:ada6a836107e9306bad16bfde83210c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fe2e53ebf5be324189578cf9c01ad0"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _size&gt; </td></tr>
<tr class="memitem:a19fe2e53ebf5be324189578cf9c01ad0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a19fe2e53ebf5be324189578cf9c01ad0">operator/</a> (<a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt; vector, const _type &amp;scalar)</td></tr>
<tr class="memdesc:a19fe2e53ebf5be324189578cf9c01ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides a vector by a scalar, c = b*a, where a, and c are vectors and b is a scalar.  <a href="namespace_disa.html#a19fe2e53ebf5be324189578cf9c01ad0">More...</a><br /></td></tr>
<tr class="separator:a19fe2e53ebf5be324189578cf9c01ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b46bad9b3703cbf6bc8cb54fde0325b"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _size_0, std::size_t _size_1&gt; </td></tr>
<tr class="memitem:a1b46bad9b3703cbf6bc8cb54fde0325b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt; <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt;, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a1b46bad9b3703cbf6bc8cb54fde0325b">operator+</a> (const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;vector0, const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;vector1)</td></tr>
<tr class="memdesc:a1b46bad9b3703cbf6bc8cb54fde0325b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two vectors together, c = a + b, where a, b, and c are vectors.  <a href="namespace_disa.html#a1b46bad9b3703cbf6bc8cb54fde0325b">More...</a><br /></td></tr>
<tr class="separator:a1b46bad9b3703cbf6bc8cb54fde0325b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6378b6629fce8f6a3fe635edb1c29d08"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _size_0, std::size_t _size_1&gt; </td></tr>
<tr class="memitem:a6378b6629fce8f6a3fe635edb1c29d08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt; <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt;, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a6378b6629fce8f6a3fe635edb1c29d08">operator-</a> (const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;vector0, const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;vector1)</td></tr>
<tr class="memdesc:a6378b6629fce8f6a3fe635edb1c29d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two vectors, c = a - b, where a, b, and c are vectors.  <a href="namespace_disa.html#a6378b6629fce8f6a3fe635edb1c29d08">More...</a><br /></td></tr>
<tr class="separator:a6378b6629fce8f6a3fe635edb1c29d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25010854ded53d844e16d8159ea09810"><td class="memTemplParams" colspan="2">template&lt;unsigned int _p_value, typename _type , std::size_t _size&gt; </td></tr>
<tr class="memitem:a25010854ded53d844e16d8159ea09810"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a25010854ded53d844e16d8159ea09810">lp_norm</a> (const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt; &amp;vector)</td></tr>
<tr class="memdesc:a25010854ded53d844e16d8159ea09810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the $L_p$-norm of a parsed vector, <img class="formulaInl" alt="$L_p = (\sum_i |a_i|^p)^1/p$" src="form_0.png"/>.  <a href="namespace_disa.html#a25010854ded53d844e16d8159ea09810">More...</a><br /></td></tr>
<tr class="separator:a25010854ded53d844e16d8159ea09810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c8821e9fe8741e3ede58b43aff5056"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _size&gt; </td></tr>
<tr class="memitem:a45c8821e9fe8741e3ede58b43aff5056"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a45c8821e9fe8741e3ede58b43aff5056">mean</a> (const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt; &amp;vector)</td></tr>
<tr class="memdesc:a45c8821e9fe8741e3ede58b43aff5056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arithmetic mean of the vector's elements.  <a href="namespace_disa.html#a45c8821e9fe8741e3ede58b43aff5056">More...</a><br /></td></tr>
<tr class="separator:a45c8821e9fe8741e3ede58b43aff5056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0883461c879694a3e8205435923e569"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _size_0, std::size_t _size_1&gt; </td></tr>
<tr class="memitem:aa0883461c879694a3e8205435923e569"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#aa0883461c879694a3e8205435923e569">dot_product</a> (const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;vector_0, const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;vector_1)</td></tr>
<tr class="memdesc:aa0883461c879694a3e8205435923e569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot(inner) product between two vectors.  <a href="namespace_disa.html#aa0883461c879694a3e8205435923e569">More...</a><br /></td></tr>
<tr class="separator:aa0883461c879694a3e8205435923e569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d4a639fc2b140b07ddb5d7b4b3f881"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _size&gt; </td></tr>
<tr class="memitem:a31d4a639fc2b140b07ddb5d7b4b3f881"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a31d4a639fc2b140b07ddb5d7b4b3f881">unit</a> (<a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt; vector)</td></tr>
<tr class="memdesc:a31d4a639fc2b140b07ddb5d7b4b3f881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a new vector with the same direction, but unit length.  <a href="namespace_disa.html#a31d4a639fc2b140b07ddb5d7b4b3f881">More...</a><br /></td></tr>
<tr class="separator:a31d4a639fc2b140b07ddb5d7b4b3f881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff048b1b87f1cd694f3539688d76fd0c"><td class="memTemplParams" colspan="2">template&lt;bool _is_radians, typename _type , std::size_t _size_0, std::size_t _size_1&gt; </td></tr>
<tr class="memitem:aff048b1b87f1cd694f3539688d76fd0c"><td class="memTemplItemLeft" align="right" valign="top">constexpr _type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#aff048b1b87f1cd694f3539688d76fd0c">angle</a> (const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;vector_0, const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;vector_1)</td></tr>
<tr class="memdesc:aff048b1b87f1cd694f3539688d76fd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the (smaller/included) angle between two vectors, computed theta = arccos (a.b/|a||b|).  <a href="namespace_disa.html#aff048b1b87f1cd694f3539688d76fd0c">More...</a><br /></td></tr>
<tr class="separator:aff048b1b87f1cd694f3539688d76fd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456feac9d4e5f11a8cab31f875cf5d8a"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _size_0, std::size_t _size_1&gt; </td></tr>
<tr class="memitem:a456feac9d4e5f11a8cab31f875cf5d8a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt; <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt;, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a456feac9d4e5f11a8cab31f875cf5d8a">cross_product</a> (const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;vector_0, const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;vector_1)</td></tr>
<tr class="memdesc:a456feac9d4e5f11a8cab31f875cf5d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cross product between two vectors, c = a x b.  <a href="namespace_disa.html#a456feac9d4e5f11a8cab31f875cf5d8a">More...</a><br /></td></tr>
<tr class="separator:a456feac9d4e5f11a8cab31f875cf5d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a4f1ca2fdd273aab99b5ba3c0f9636"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _size_0, std::size_t _size_1&gt; </td></tr>
<tr class="memitem:a82a4f1ca2fdd273aab99b5ba3c0f9636"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt; <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt;, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a82a4f1ca2fdd273aab99b5ba3c0f9636">projection_tangent</a> (const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;vector_0, const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;vector_1)</td></tr>
<tr class="memdesc:a82a4f1ca2fdd273aab99b5ba3c0f9636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects a vector, a, onto a second vector, b, i.e.  <a href="namespace_disa.html#a82a4f1ca2fdd273aab99b5ba3c0f9636">More...</a><br /></td></tr>
<tr class="separator:a82a4f1ca2fdd273aab99b5ba3c0f9636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83759d9ece7a6cba4e733b6e7dcb55fd"><td class="memTemplParams" colspan="2">template&lt;typename _type , std::size_t _size_0, std::size_t _size_1&gt; </td></tr>
<tr class="memitem:a83759d9ece7a6cba4e733b6e7dcb55fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt; <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt;, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a83759d9ece7a6cba4e733b6e7dcb55fd">projection_orthogonal</a> (const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;vector_0, const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;vector_1)</td></tr>
<tr class="memdesc:a83759d9ece7a6cba4e733b6e7dcb55fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects a vector, a, such that the projection is orthogonal to a second vector, b.  <a href="namespace_disa.html#a83759d9ece7a6cba4e733b6e7dcb55fd">More...</a><br /></td></tr>
<tr class="separator:a83759d9ece7a6cba4e733b6e7dcb55fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3cad1511bda44d82010b22562a1517"><td class="memTemplParams" colspan="2">template&lt;bool _directed&gt; </td></tr>
<tr class="memitem:a2f3cad1511bda44d82010b22562a1517"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a2f3cad1511bda44d82010b22562a1517">operator&lt;&lt;</a> (std::ostream &amp;ostream, const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; _directed &gt; &amp;graph)</td></tr>
<tr class="memdesc:a2f3cad1511bda44d82010b22562a1517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded stream operator for the out stream, writes out a formatted graph.  <a href="namespace_disa.html#a2f3cad1511bda44d82010b22562a1517">More...</a><br /></td></tr>
<tr class="separator:a2f3cad1511bda44d82010b22562a1517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf26006229af6790528099b84e91d6c"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; const std::size_t &amp;, const std::size_t &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a5bf26006229af6790528099b84e91d6c">order_edge_vertex</a> (const <a class="el" href="namespace_disa.html#a5d0458dbd92d3cbd94eddeb318b6d88f">Edge</a> *edge)</td></tr>
<tr class="memdesc:a5bf26006229af6790528099b84e91d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of an edge, alias for a pair of unsigned ints.  <a href="namespace_disa.html#a5bf26006229af6790528099b84e91d6c">More...</a><br /></td></tr>
<tr class="separator:a5bf26006229af6790528099b84e91d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a859298aab9e256762d7ee0ddda55a"><td class="memTemplParams" colspan="2">template&lt;bool _directed&gt; </td></tr>
<tr class="memitem:a11a859298aab9e256762d7ee0ddda55a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; _directed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a11a859298aab9e256762d7ee0ddda55a">create_graph_line</a> (std::size_t number_vertices)</td></tr>
<tr class="memdesc:a11a859298aab9e256762d7ee0ddda55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a line Adjacency Graph consisting of n vertices.  <a href="namespace_disa.html#a11a859298aab9e256762d7ee0ddda55a">More...</a><br /></td></tr>
<tr class="separator:a11a859298aab9e256762d7ee0ddda55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70f63660d821d097cabfa65d2f15020"><td class="memTemplParams" colspan="2">template&lt;bool _directed&gt; </td></tr>
<tr class="memitem:ae70f63660d821d097cabfa65d2f15020"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; _directed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#ae70f63660d821d097cabfa65d2f15020">create_graph_structured</a> (std::size_t number_vertices)</td></tr>
<tr class="memdesc:ae70f63660d821d097cabfa65d2f15020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a structured grid Adjacency Graph consisting of n^2 vertices.  <a href="namespace_disa.html#ae70f63660d821d097cabfa65d2f15020">More...</a><br /></td></tr>
<tr class="separator:ae70f63660d821d097cabfa65d2f15020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf8e949e818de5895404f8d77e3efc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a7bf8e949e818de5895404f8d77e3efc7">create_graph_hybrid</a> ()</td></tr>
<tr class="memdesc:a7bf8e949e818de5895404f8d77e3efc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms an Adjacency Graph with both 'triangular' and 'quadrilateral' type connectivity.  <a href="namespace_disa.html#a7bf8e949e818de5895404f8d77e3efc7">More...</a><br /></td></tr>
<tr class="separator:a7bf8e949e818de5895404f8d77e3efc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ee8784ce19eea1db6ab8b243d106a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a07ee8784ce19eea1db6ab8b243d106a6">create_graph_saad</a> ()</td></tr>
<tr class="memdesc:a07ee8784ce19eea1db6ab8b243d106a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates one of the example graphs from the text book Iterative Methods for Sparse Linear Systems.  <a href="namespace_disa.html#a07ee8784ce19eea1db6ab8b243d106a6">More...</a><br /></td></tr>
<tr class="separator:a07ee8784ce19eea1db6ab8b243d106a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946a4aa8be66636850f22969a357d6e3"><td class="memTemplParams" colspan="2">template&lt;class _graph &gt; </td></tr>
<tr class="memitem:a946a4aa8be66636850f22969a357d6e3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a946a4aa8be66636850f22969a357d6e3">level_traversal</a> (const _graph &amp;graph, const std::size_t i_start, const std::size_t end_level=std::numeric_limits&lt; std::size_t &gt;::max())</td></tr>
<tr class="memdesc:a946a4aa8be66636850f22969a357d6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs level traversal on a given graph starting from a specified vertex and returns a vector that stores the level of each vertex.  <a href="namespace_disa.html#a946a4aa8be66636850f22969a357d6e3">More...</a><br /></td></tr>
<tr class="separator:a946a4aa8be66636850f22969a357d6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ac38de58fda28f083fe8865879e00a"><td class="memTemplParams" colspan="2">template&lt;class _graph &gt; </td></tr>
<tr class="memitem:a09ac38de58fda28f083fe8865879e00a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a09ac38de58fda28f083fe8865879e00a">level_traversal</a> (const _graph &amp;graph, std::queue&lt; std::size_t &gt; &amp;vertex_queue, std::vector&lt; std::size_t &gt; &amp;vertex_level, const std::size_t end_level=std::numeric_limits&lt; std::size_t &gt;::max())</td></tr>
<tr class="memdesc:a09ac38de58fda28f083fe8865879e00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform level traversal on a given graph starting from a given vertex queue and stores the level of each vertex in a vector.  <a href="namespace_disa.html#a09ac38de58fda28f083fe8865879e00a">More...</a><br /></td></tr>
<tr class="separator:a09ac38de58fda28f083fe8865879e00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c59e5dc83aa26fafaf230ad9a29aeed"><td class="memTemplParams" colspan="2">template&lt;class _graph &gt; </td></tr>
<tr class="memitem:a4c59e5dc83aa26fafaf230ad9a29aeed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a4c59e5dc83aa26fafaf230ad9a29aeed">level_expansion</a> (const _graph &amp;graph, const std::vector&lt; std::size_t &gt; &amp;seeds, std::vector&lt; std::size_t &gt; &amp;vertex_color)</td></tr>
<tr class="memdesc:a4c59e5dc83aa26fafaf230ad9a29aeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a level-set expansion to color a parsed graph from a set of seed vertices, where the color of each vertex is associated with the 'closest' seed vertex.  <a href="namespace_disa.html#a4c59e5dc83aa26fafaf230ad9a29aeed">More...</a><br /></td></tr>
<tr class="separator:a4c59e5dc83aa26fafaf230ad9a29aeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4545c645058204de6bd28e10681f9a9"><td class="memTemplParams" colspan="2">template&lt;class _graph &gt; </td></tr>
<tr class="memitem:ad4545c645058204de6bd28e10681f9a9"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#ad4545c645058204de6bd28e10681f9a9">pseudo_peripheral_vertex</a> (const _graph &amp;graph, std::size_t i_start=0)</td></tr>
<tr class="memdesc:ad4545c645058204de6bd28e10681f9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a pseudo peripheral vertex in the parsed graph.  <a href="namespace_disa.html#ad4545c645058204de6bd28e10681f9a9">More...</a><br /></td></tr>
<tr class="separator:ad4545c645058204de6bd28e10681f9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6366f3d734594bd7411598b839ee5912"><td class="memTemplParams" colspan="2">template&lt;class _graph &gt; </td></tr>
<tr class="memitem:a6366f3d734594bd7411598b839ee5912"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a6366f3d734594bd7411598b839ee5912">eccentricity_graph</a> (const _graph &amp;graph, std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &amp;eccentricity)</td></tr>
<tr class="memdesc:a6366f3d734594bd7411598b839ee5912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eccentricity of all vertices in the graph using the breadth-first search algorithm.  <a href="namespace_disa.html#a6366f3d734594bd7411598b839ee5912">More...</a><br /></td></tr>
<tr class="separator:a6366f3d734594bd7411598b839ee5912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af567d3896f170a065339bfb89deef1b0"><td class="memTemplParams" colspan="2">template&lt;class _graph &gt; </td></tr>
<tr class="memitem:af567d3896f170a065339bfb89deef1b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#af567d3896f170a065339bfb89deef1b0">eccentricity_vertex_breadth_first</a> (const _graph &amp;graph, const std::size_t i_start, std::vector&lt; std::size_t &gt; &amp;distance, const std::size_t i_stop=std::numeric_limits&lt; std::size_t &gt;::max())</td></tr>
<tr class="memdesc:af567d3896f170a065339bfb89deef1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform breadth-first search to compute the eccentricity of each vertex in a graph from a given vertex.  <a href="namespace_disa.html#af567d3896f170a065339bfb89deef1b0">More...</a><br /></td></tr>
<tr class="separator:af567d3896f170a065339bfb89deef1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998d530594fbf6d8c44cb746ab7608c5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a998d530594fbf6d8c44cb746ab7608c5">cuthill_mckee_reverse</a> (const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt; &amp;graph, std::size_t root_vertex=std::numeric_limits&lt; std::size_t &gt;::max())</td></tr>
<tr class="memdesc:a998d530594fbf6d8c44cb746ab7608c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a permutation vector given non-disjoint graph using the Reverse Cuthill-Mckee algorithm.  <a href="namespace_disa.html#a998d530594fbf6d8c44cb746ab7608c5">More...</a><br /></td></tr>
<tr class="separator:a998d530594fbf6d8c44cb746ab7608c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989af41b535128aecf8d0680d86f6ae8"><td class="memTemplParams" colspan="2">template&lt;class _matrix , class _vector &gt; </td></tr>
<tr class="memitem:a989af41b535128aecf8d0680d86f6ae8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a989af41b535128aecf8d0680d86f6ae8">compute_residual</a> (const _matrix &amp;coef, const _vector &amp;solution, const _vector &amp;constant)</td></tr>
<tr class="memdesc:a989af41b535128aecf8d0680d86f6ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently computes various scalar residual's of a linear system, e.g.  <a href="namespace_disa.html#a989af41b535128aecf8d0680d86f6ae8">More...</a><br /></td></tr>
<tr class="separator:a989af41b535128aecf8d0680d86f6ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1c49faaab8fc3e11899afcaf065ebd1d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a1c49faaab8fc3e11899afcaf065ebd1d">scalar_max_digits10</a> = std::numeric_limits&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;::max_digits10</td></tr>
<tr class="memdesc:a1c49faaab8fc3e11899afcaf065ebd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for scalar max_digits10.  <a href="namespace_disa.html#a1c49faaab8fc3e11899afcaf065ebd1d">More...</a><br /></td></tr>
<tr class="separator:a1c49faaab8fc3e11899afcaf065ebd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba5e5cba5f93f1f374fde90b8004f33"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a7ba5e5cba5f93f1f374fde90b8004f33">scalar_epsilon</a> = std::numeric_limits&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;::epsilon()</td></tr>
<tr class="memdesc:a7ba5e5cba5f93f1f374fde90b8004f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for scalar epsilon.  <a href="namespace_disa.html#a7ba5e5cba5f93f1f374fde90b8004f33">More...</a><br /></td></tr>
<tr class="separator:a7ba5e5cba5f93f1f374fde90b8004f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36831b38dd18e0850fdbf66cc411589"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#af36831b38dd18e0850fdbf66cc411589">scalar_infinity</a> = std::numeric_limits&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;::infinity()</td></tr>
<tr class="memdesc:af36831b38dd18e0850fdbf66cc411589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for scalar infinity.  <a href="namespace_disa.html#af36831b38dd18e0850fdbf66cc411589">More...</a><br /></td></tr>
<tr class="separator:af36831b38dd18e0850fdbf66cc411589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4606e08e37c5f0788bed13690b590f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#aaa4606e08e37c5f0788bed13690b590f">scalar_lowest</a> = std::numeric_limits&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;::lowest()</td></tr>
<tr class="memdesc:aaa4606e08e37c5f0788bed13690b590f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for scalar lowest.  <a href="namespace_disa.html#aaa4606e08e37c5f0788bed13690b590f">More...</a><br /></td></tr>
<tr class="separator:aaa4606e08e37c5f0788bed13690b590f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f0e41a0d2a61294284a230df8dde39"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a02f0e41a0d2a61294284a230df8dde39">scalar_max</a> = std::numeric_limits&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;::max()</td></tr>
<tr class="memdesc:a02f0e41a0d2a61294284a230df8dde39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for scalar max.  <a href="namespace_disa.html#a02f0e41a0d2a61294284a230df8dde39">More...</a><br /></td></tr>
<tr class="separator:a02f0e41a0d2a61294284a230df8dde39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f2f0b7a88ef69ff7f5b3d4b6d7a7ac"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a12f2f0b7a88ef69ff7f5b3d4b6d7a7ac">scalar_min</a> = std::numeric_limits&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;::min()</td></tr>
<tr class="memdesc:a12f2f0b7a88ef69ff7f5b3d4b6d7a7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for scalar min.  <a href="namespace_disa.html#a12f2f0b7a88ef69ff7f5b3d4b6d7a7ac">More...</a><br /></td></tr>
<tr class="separator:a12f2f0b7a88ef69ff7f5b3d4b6d7a7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0e38acec7e979eee6eaddf423d93b7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#a0f0e38acec7e979eee6eaddf423d93b7">default_absolute</a> = static_cast&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;(64)*<a class="el" href="namespace_disa.html#a7ba5e5cba5f93f1f374fde90b8004f33">scalar_epsilon</a></td></tr>
<tr class="memdesc:a0f0e38acec7e979eee6eaddf423d93b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global for default absolute equality check, 'reasonably over 2 orders of epsilon.  <a href="namespace_disa.html#a0f0e38acec7e979eee6eaddf423d93b7">More...</a><br /></td></tr>
<tr class="separator:a0f0e38acec7e979eee6eaddf423d93b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf188d2f52238f11ae72c35ff61d996"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_disa.html#acbf188d2f52238f11ae72c35ff61d996">default_relative</a> = static_cast&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;(65536)*<a class="el" href="namespace_disa.html#a7ba5e5cba5f93f1f374fde90b8004f33">scalar_epsilon</a></td></tr>
<tr class="memdesc:acbf188d2f52238f11ae72c35ff61d996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global for default relative equality check, 'reasonably over 4 orders of epsilon.  <a href="namespace_disa.html#acbf188d2f52238f11ae72c35ff61d996">More...</a><br /></td></tr>
<tr class="separator:acbf188d2f52238f11ae72c35ff61d996"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a5d0458dbd92d3cbd94eddeb318b6d88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0458dbd92d3cbd94eddeb318b6d88f">&#9670;&nbsp;</a></span>Edge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_disa.html#a5d0458dbd92d3cbd94eddeb318b6d88f">Edge</a> =  std::pair&lt;std::size_t, std::size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a292ef5870b9a88a0657959d670390c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292ef5870b9a88a0657959d670390c41">&#9670;&nbsp;</a></span>s_size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_disa.html#a292ef5870b9a88a0657959d670390c41">s_size_t</a> =  std::make_signed&lt;std::size_t&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for static casting where needed, and to prevent compile warnings (if you are using a signed type for size_t, you are doing something wrong). </p>

</div>
</div>
<a id="a8c2981f3f834be9448a6ab06c28748eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2981f3f834be9448a6ab06c28748eb">&#9670;&nbsp;</a></span>Scalar</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> =  double</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a398ac024b656d2e99d3f07e22b7d4d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398ac024b656d2e99d3f07e22b7d4d5e">&#9670;&nbsp;</a></span>Solver_Gauss_Seidel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_disa_1_1_solver___fixed___point.html">Solver_Fixed_Point</a>&lt;<a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987bacd9152dc4c50cce6f3cab9c7bfe58c4f">Solver_Type::gauss_seidel</a>, <a class="el" href="struct_disa_1_1_solver___fixed___point___data.html">Solver_Fixed_Point_Data</a>&gt; <a class="el" href="namespace_disa.html#a398ac024b656d2e99d3f07e22b7d4d5e">Solver_Gauss_Seidel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad0db03cf0bcf32b769d6b5adb2bb0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0db03cf0bcf32b769d6b5adb2bb0b7">&#9670;&nbsp;</a></span>Solver_Jacobi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_disa_1_1_solver___fixed___point.html">Solver_Fixed_Point</a>&lt;<a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987ba1606457c201437c4f914a83939e25722">Solver_Type::jacobi</a>, <a class="el" href="struct_disa_1_1_solver___fixed___point___jacobi___data.html">Solver_Fixed_Point_Jacobi_Data</a>&gt; <a class="el" href="namespace_disa.html#aad0db03cf0bcf32b769d6b5adb2bb0b7">Solver_Jacobi</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a516103eb569d14a1941f8c15d3ce108a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516103eb569d14a1941f8c15d3ce108a">&#9670;&nbsp;</a></span>Solver_LU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_disa.html#a516103eb569d14a1941f8c15d3ce108a">Solver_LU</a> =  <a class="el" href="class_disa_1_1_direct___lower___upper___factorisation.html">Direct_Lower_Upper_Factorisation</a>&lt;<a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987ba8742060c1cb1135de58ec175157374f8">Solver_Type::lower_upper_factorisation</a>, _size, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b2a6b61cf124143cb8befeabf5d2f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2a6b61cf124143cb8befeabf5d2f38">&#9670;&nbsp;</a></span>Solver_LUP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_disa.html#a1b2a6b61cf124143cb8befeabf5d2f38">Solver_LUP</a> =  <a class="el" href="class_disa_1_1_direct___lower___upper___factorisation.html">Direct_Lower_Upper_Factorisation</a>&lt;<a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987ba8742060c1cb1135de58ec175157374f8">Solver_Type::lower_upper_factorisation</a>, _size, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc152cbbb1cc37d652c24e622489b50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc152cbbb1cc37d652c24e622489b50a">&#9670;&nbsp;</a></span>Sover_Sor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_disa_1_1_solver___fixed___point.html">Solver_Fixed_Point</a>&lt;<a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987bab3a4458f26ca796419728e53b8c9c79d">Solver_Type::successive_over_relaxation</a>, <a class="el" href="struct_disa_1_1_solver___fixed___point___sor___data.html">Solver_Fixed_Point_Sor_Data</a>&gt; <a class="el" href="namespace_disa.html#abc152cbbb1cc37d652c24e622489b50a">Sover_Sor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6ad351ea7d2afe4c8726f1e0fd6a0b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad351ea7d2afe4c8726f1e0fd6a0b0e">&#9670;&nbsp;</a></span>Log_Level</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_disa.html#a6ad351ea7d2afe4c8726f1e0fd6a0b0e">Log_Level</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logging Level, used to defines the severity of messages to the console. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6ad351ea7d2afe4c8726f1e0fd6a0b0ea902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6ad351ea7d2afe4c8726f1e0fd6a0b0ea0eaadb4fcb48a0a0ed7bc9868be9fbaa"></a>Warning&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6ad351ea7d2afe4c8726f1e0fd6a0b0ea4059b0251f66a18cb56f544728796875"></a>Info&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6ad351ea7d2afe4c8726f1e0fd6a0b0eaa603905470e2a5b8c13e96b579ef0dba"></a>Debug&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a5cc27b15a9dee0ad91cc0f746fcd987b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc27b15a9dee0ad91cc0f746fcd987b">&#9670;&nbsp;</a></span>Solver_Type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_disa.html#a5cc27b15a9dee0ad91cc0f746fcd987b">Solver_Type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerated list of all linear solvers in <a class="el" href="namespace_disa.html">Disa</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5cc27b15a9dee0ad91cc0f746fcd987ba8742060c1cb1135de58ec175157374f8"></a>lower_upper_factorisation&#160;</td><td class="fielddoc"><p>The Lower Upper Factorisation solver (Dense Systems). </p>
</td></tr>
<tr><td class="fieldname"><a id="a5cc27b15a9dee0ad91cc0f746fcd987ba1606457c201437c4f914a83939e25722"></a>jacobi&#160;</td><td class="fielddoc"><p>The Jacobi fixed point iterative solver (Sparse Systems). </p>
</td></tr>
<tr><td class="fieldname"><a id="a5cc27b15a9dee0ad91cc0f746fcd987bacd9152dc4c50cce6f3cab9c7bfe58c4f"></a>gauss_seidel&#160;</td><td class="fielddoc"><p>The Gauss Seidel fixed point iterative solver (Sparse Systems). </p>
</td></tr>
<tr><td class="fieldname"><a id="a5cc27b15a9dee0ad91cc0f746fcd987bab3a4458f26ca796419728e53b8c9c79d"></a>successive_over_relaxation&#160;</td><td class="fielddoc"><p>The Successive Over Relaxation fixed point iterative solver (Sparse Systems). </p>
</td></tr>
<tr><td class="fieldname"><a id="a5cc27b15a9dee0ad91cc0f746fcd987baad921d60486366258809553a3db49a4a"></a>unknown&#160;</td><td class="fielddoc"><p>Uninitialised/Unknown solver. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aff048b1b87f1cd694f3539688d76fd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff048b1b87f1cd694f3539688d76fd0c">&#9670;&nbsp;</a></span>angle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _type Disa::angle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the (smaller/included) angle between two vectors, computed theta = arccos (a.b/|a||b|). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_is_radians</td><td>Must the returned angle be computed in radians or degrees. </td></tr>
    <tr><td class="paramname">_size_0</td><td>Size of the first vector if static, else 0. </td></tr>
    <tr><td class="paramname">_size_1</td><td>Size of the second vector if static, else 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_0</td><td>The first vector, a. </td></tr>
    <tr><td class="paramname">vector_1</td><td>The second vector, b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The angle between the vectors. </dd></dl>

</div>
</div>
<a id="a523c6673ab5cddb1961a16af22f8e95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523c6673ab5cddb1961a16af22f8e95f">&#9670;&nbsp;</a></span>backward_sweep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Disa::backward_sweep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;&#160;</td>
          <td class="paramname"><em>a_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, 0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, 0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, 0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acf04b38f6a4f93b737ffb6ac2b433224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf04b38f6a4f93b737ffb6ac2b433224">&#9670;&nbsp;</a></span>breadth_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; breadth_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>start_vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a permutation vector for a given non-disjoint graph using the bread first (search) algorithm. </p>
<p>The implementation of this breadth first search (BFS) follows pretty standard queue based approach which is readily searchable online (two links below). The algorithm reorders the graph through an 'advancing front' or 'level-set' of unvisited vertices which are adjacent to those already visited. At each iteration the front of the visited vertex queue is added to the permutation vector before it popped off the queue. While vertex's unvisited adjacent neighbours are added to the back of the queue: A 'first-in first-out' queue principle.</p>
<p>Perhaps some minor differences to note:</p><ol type="1">
<li>We are not doing a search here, all vertices are visited. Hence the removal of the 'search' term in the name.</li>
<li>Currently this implementation only supports fully joined graphs.</li>
</ol>
<p>References: <a href="https://en.wikipedia.org/wiki/Breadth-first_search">https://en.wikipedia.org/wiki/Breadth-first_search</a> <a href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/">https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph to reorder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_vertex</td><td>The new graph root vertex, or starting vertex for the reordering. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector mapping the old to new graph, i.e. new_index = permutation[old_index]. </dd></dl>

</div>
</div>
<a id="aefb94f81769534f4e368f72f9f7c2721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb94f81769534f4e368f72f9f7c2721">&#9670;&nbsp;</a></span>build_solver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_solver.html">Solver</a> build_solver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_disa_1_1_solver___config.html">Solver_Config</a>&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a989af41b535128aecf8d0680d86f6ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989af41b535128aecf8d0680d86f6ae8">&#9670;&nbsp;</a></span>compute_residual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &gt; compute_residual </td>
          <td>(</td>
          <td class="paramtype">const _matrix &amp;&#160;</td>
          <td class="paramname"><em>coef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _vector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _vector &amp;&#160;</td>
          <td class="paramname"><em>constant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Efficiently computes various scalar residual's of a linear system, e.g. </p>
<p>|r|= |Ax - b| </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_matrix</td><td>Matrix type, dense/sparse/dynamic/static/etc, of A. </td></tr>
    <tr><td class="paramname">_vector</td><td>Vector type, dynamic/static, of x and b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coef</td><td>The (sparse) coefficient matrix of the linear system, A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution</td><td>The solution vector of the linear system, x. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constant</td><td>The constant vector of the linear system, b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The l2_norm (accounting for the system size, n) and l_inf norms of the residual vector, r.</dd></dl>
<p>Computes the size weighed l-norms of the residual vector in a computationally efficient way. This is achieved via fusing the matrix-vector and l_2 norm operations in a single loop. For the linear system</p>
<p>A*x = b,</p>
<p>the residual vector is defined as</p>
<p>r = Ax - b,</p>
<p>and the size weighted l_2-norm, and l_inf norm as</p>
<p>|r|_{2,n} = (1/n sum_i r_i^2)^{1/2}, |r|_{inf} = max_i |r_i|.</p>
<p>where A - The coefficient matrix of the linear system. x - The current solution vector of the linear system. b - The constant vector of the linear system. r - The residual vector of the linear system. n - The size (number of rows/columns) of the system. </p>

</div>
</div>
<a id="a313943c669dbb0d1eff816585b62c881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313943c669dbb0d1eff816585b62c881">&#9670;&nbsp;</a></span>console_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt;char&gt; Disa::console_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a6ad351ea7d2afe4c8726f1e0fd6a0b0e">Log_Level</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::source_location &amp;&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds additional information to messages about to be printed to screen, such as file and line numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Logging level enumerator, determine prefixing of returned string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>Source code location object, containing the origin of the console message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Formatted string: '[logging level | file name::line number]:' </dd></dl>

</div>
</div>
<a id="a7bf8e949e818de5895404f8d77e3efc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf8e949e818de5895404f8d77e3efc7">&#9670;&nbsp;</a></span>create_graph_hybrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt;false&gt; Disa::create_graph_hybrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forms an Adjacency Graph with both 'triangular' and 'quadrilateral' type connectivity. </p>
<dl class="section return"><dt>Returns</dt><dd>The created Adjacency Graph.</dd></dl>
<p>Below is the vertex indexing and topology of the returned adjacency graph.</p>
<p>0 - 1 - 2 | | | 3 - 4 - 5 \ / \ / 6 - 7 </p>

</div>
</div>
<a id="a11a859298aab9e256762d7ee0ddda55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a859298aab9e256762d7ee0ddda55a">&#9670;&nbsp;</a></span>create_graph_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt;_directed&gt; Disa::create_graph_line </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>number_vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a line Adjacency Graph consisting of n vertices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_directed</td><td>Whether the graph is directed or not, directed graphs point in an ascending fashion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">number_vertices</td><td>The number of vertices n to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created Adjacency Graph.</dd></dl>
<p>The topology of the Adjacency Graph is depicted below, with the ordering of the vertex indices.</p>
<p>directed: <br  />
 0 &gt; 1 &gt; ... &gt; n-2 &gt; n-1</p>
<p>undirected: 0 - 1 - ... - n-2 - n-1 </p>

</div>
</div>
<a id="a07ee8784ce19eea1db6ab8b243d106a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ee8784ce19eea1db6ab8b243d106a6">&#9670;&nbsp;</a></span>create_graph_saad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt;false&gt; Disa::create_graph_saad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates one of the example graphs from the text book Iterative Methods for Sparse Linear Systems. </p>
<dl class="section return"><dt>Returns</dt><dd>The created Saad Adjacency Graph.</dd></dl>
<p>5 | \ 14 - 13 | \ | \ 3 - 11 - 4 | / | / | 12 - 10 - 9 | / | / | 1 - 7 - 2 | / | / 8 - 6 | / 0</p>
<dl class="section note"><dt>Note</dt><dd>: Reference DOI: <a href="https://doi.org/10.1137/1.9780898718003">https://doi.org/10.1137/1.9780898718003</a> </dd></dl>

</div>
</div>
<a id="ae70f63660d821d097cabfa65d2f15020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70f63660d821d097cabfa65d2f15020">&#9670;&nbsp;</a></span>create_graph_structured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt;_directed&gt; Disa::create_graph_structured </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>number_vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a structured grid Adjacency Graph consisting of n^2 vertices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_directed</td><td>Whether the graph is directed or not, directed graphs point in an ascending fashion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">number_vertices</td><td>The number of vertices n along one of the 'axis'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created Adjacency Graph.</dd></dl>
<p>The topology of the Adjacency Graph is depicted below, with the ordering of the vertex indices.</p>
<p>directed: n^2-n &gt; n^2-(n+1) &gt; ... &gt; n^2-2 &gt; n^2-1 ^ ^ ^ ^ ^ ... &gt; &gt; ... &gt; ... &gt; ... ^ ^ ^ ^ ^ n &gt; n+1 &gt; ... &gt; 2n-2 &gt; 2n-1 ^ ^ ^ ^ ^ 0 &gt; 1 &gt; ... &gt; n-2 &gt; n-1</p>
<p>undirected: n^2-n - n^2-(n+1) - ... - n^2-2 - n^2-1 | | | | | ... - - ... - ... - ... | | | | | n - n+1 - ... - 2n-2 - 2n-1 | | | | | 0 - 1 - ... - n-2 - n-1 </p>

</div>
</div>
<a id="a456feac9d4e5f11a8cab31f875cf5d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456feac9d4e5f11a8cab31f875cf5d8a">&#9670;&nbsp;</a></span>cross_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt;<a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size_0&gt;, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size_1&gt; &gt;::type Disa::cross_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cross product between two vectors, c = a x b. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_size_0</td><td>Size of the first vector if static, else 0. </td></tr>
    <tr><td class="paramname">_size_1</td><td>Size of the second vector if static, else 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vector_0</td><td>The first vector, a, of the cross product. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vector_1</td><td>The second vector, a, of the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector orthogonal (to a and b) vector c. </dd></dl>

</div>
</div>
<a id="a07cb4eaebee2a4bfcc4350470a586274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cb4eaebee2a4bfcc4350470a586274">&#9670;&nbsp;</a></span>cuthill_mckee()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; cuthill_mckee </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>start_vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a permutation vector given non-disjoint graph using the Cuthill-Mckee algorithm. </p>
<p>Similar to the BFS algorithm this function implements a queue based Cuthill McKee (CMK) method. As with other level-set orderings an 'advancing front' of unvisited vertices are created and updated around the already visited vertices. The CMK method, however, starts by searching for a suitable start vertex (if one is not provided), by looking for a/the vertex with the lowest degree in the graph. Technically, this should be a periphery vertex, but this implementation does not check for this. Similarly, no errors will be thrown should the user parse a vertex index that is neither the lowest degree nor that is non-periphery. Finally the queue itself is added to in a manner that 'new vertices' are sorted from lowest to highest degree before being placed in the queue.</p>
<p>References: <a href="https://en.wikipedia.org/wiki/Cuthill%E2%80%93McKee_algorithm">https://en.wikipedia.org/wiki/Cuthill%E2%80%93McKee_algorithm</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph to reorder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_vertex</td><td>The new graph root vertex, if default a periphery node will be search for. Defaults to max(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector mapping the old to new graph, i.e. new_index = re_order[old_index]. </dd></dl>

</div>
</div>
<a id="a998d530594fbf6d8c44cb746ab7608c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998d530594fbf6d8c44cb746ab7608c5">&#9670;&nbsp;</a></span>cuthill_mckee_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; Disa::cuthill_mckee_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>root_vertex</em> = <code>std::numeric_limits&lt;std::size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a permutation vector given non-disjoint graph using the Reverse Cuthill-Mckee algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph to reorder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_vertex</td><td>The new graph root vertex, if default a periphery node will be search for. Defaults to max(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector mapping the old to new graph, i.e. new_index = permutation[old_index]. </dd></dl>

</div>
</div>
<a id="aa0883461c879694a3e8205435923e569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0883461c879694a3e8205435923e569">&#9670;&nbsp;</a></span>dot_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> Disa::dot_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the dot(inner) product between two vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_size_0</td><td>Size of the first vector if static, else 0. </td></tr>
    <tr><td class="paramname">_size_1</td><td>Size of the second vector if static, else 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_0</td><td>The first vector to be dotted. </td></tr>
    <tr><td class="paramname">vector_1</td><td>The second vector to be dotted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar result. </dd></dl>

</div>
</div>
<a id="a6366f3d734594bd7411598b839ee5912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6366f3d734594bd7411598b839ee5912">&#9670;&nbsp;</a></span>eccentricity_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Disa::eccentricity_graph </td>
          <td>(</td>
          <td class="paramtype">const _graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>eccentricity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the eccentricity of all vertices in the graph using the breadth-first search algorithm. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_graph</td><td>Type of the input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>A graph containing the vertices for which the eccentricity is to be computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eccentricity</td><td>Output vector of vectors containing the eccentricity of each vertex in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af567d3896f170a065339bfb89deef1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af567d3896f170a065339bfb89deef1b0">&#9670;&nbsp;</a></span>eccentricity_vertex_breadth_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Disa::eccentricity_vertex_breadth_first </td>
          <td>(</td>
          <td class="paramtype">const _graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i_stop</em> = <code>std::numeric_limits&lt;std::size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform breadth-first search to compute the eccentricity of each vertex in a graph from a given vertex. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_graph</td><td>The type of the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>A non-empty graph to search for a peripheral vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_start</td><td>The index of the starting vertex, i.e. computed distance will be from this vertex to all others. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distance</td><td>Vector to store the distances between the starting vertex and each vertex in the graph. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_stop</td><td>The index of a stopping vertex, defaults to max. See details.</td></tr>
  </table>
  </dd>
</dl>
<p>The function uses a queue to store the vertices to be visited and updates the distance vector as it performs a breath first search. If the index of the vertex at the front of the queue is greater than or equal to i_stop it is not visited, this can improve performance when building full eccentricities which are symmetric. </p>

</div>
</div>
<a id="a6deefe8e3aefb6e6e2699e3d6751aad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6deefe8e3aefb6e6e2699e3d6751aad6">&#9670;&nbsp;</a></span>forward_sweep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Disa::forward_sweep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;&#160;</td>
          <td class="paramname"><em>a_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, 0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, 0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, 0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fb0d3be9790d345b48e09008ac179f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb0d3be9790d345b48e09008ac179f0">&#9670;&nbsp;</a></span>greedy_multicolouring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; greedy_multicolouring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a permutation vector given non-disjoint graph using a multicolouring algorithm. </p>
<p>A greedy method for multicolouring (sometimes just colouring) of a graph. First, the vertices in the graph are iterated through. At each iteration a vertex is coloured by finding the first/lowest unique colour not present in the colours of adjacent vertices. Here the colours are represented by positive integers, with zero representing unassigned. Once all vertices have been colour the permutation vector is creating by looping over the colours and adding any vertices of that colour to the vector. Note: this means that the resulting permutation is essentially sorted first by colour, and then by vertex index (of the original graph).</p>
<p>References: <a href="https://en.wikipedia.org/wiki/Greedy_coloring#">https://en.wikipedia.org/wiki/Greedy_coloring#</a> <a href="https://www.geeksforgeeks.org/graph-coloring-set-2-greedy-algorithm/">https://www.geeksforgeeks.org/graph-coloring-set-2-greedy-algorithm/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph to reorder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The permutation vector mapping the old to new graph, i.e. new_index = permutation[old_index]. </dd></dl>

</div>
</div>
<a id="a4a2e6c44ba8374882573d628b743271d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2e6c44ba8374882573d628b743271d">&#9670;&nbsp;</a></span>is_nearly_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Disa::is_nearly_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance_relative</em> = <code><a class="el" href="namespace_disa.html#acbf188d2f52238f11ae72c35ff61d996">default_relative</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance_absolute</em> = <code><a class="el" href="namespace_disa.html#a0f0e38acec7e979eee6eaddf423d93b7">default_absolute</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two scalars are 'almost' equal to each other, using tolerancing. </p>
<p>I.e. definition of an operator=~. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_0</td><td>The first scalar value, s_0, to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_1</td><td>The second scalar value, s_1, to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance_relative</td><td>Tolerance value, tol_rel, below which two the normalised scalars are considered equal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance_absolute</td><td>Cutoff tolerance value, tol_abs, below which two the scalars are considered equal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the scalars are nearly equal to each other, s_0 =~ s_1.</dd></dl>
<p>A number of floating point equality check cases are handled by the implementation used here, most programmers should be familiar with the issues surrounding floating point equality checks, without needing to go into too much depth here. Below is a mathematical description of the list of the cases that are considered here followed by a link to a very useful discussion and the solution for equality checking regarding floating point numbers.</p>
<p>Cases:</p><ol type="1">
<li>norm &gt; scalar_max : |s_0 - s_1|/max_scalar &lt; tol_rel</li>
<li>eps_abs &lt; norm &lt; scalar_max : |s_0 - s_1|/norm &lt; tol_rel</li>
<li>eps_abs &gt; norm : |s_0 - s_1| &lt; tol_abs where</li>
</ol>
<ul>
<li>norm = |s_0| + |s_1|</li>
<li>scalar_max = std::numeric_limits&lt;Scalar&gt;::max(), maximum floating point representation of scalar values.</li>
</ul>
<p>Note: Solution taken from <a href="https://stackoverflow.com/questions/4915462/how-should-i-do-floating-point-comparison">https://stackoverflow.com/questions/4915462/how-should-i-do-floating-point-comparison</a> </p>

</div>
</div>
<a id="aa779399caa791454283aac3a9627a869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa779399caa791454283aac3a9627a869">&#9670;&nbsp;</a></span>is_nearly_greater()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Disa::is_nearly_greater </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance_relative</em> = <code><a class="el" href="namespace_disa.html#acbf188d2f52238f11ae72c35ff61d996">default_relative</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance_absolute</em> = <code><a class="el" href="namespace_disa.html#a0f0e38acec7e979eee6eaddf423d93b7">default_absolute</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a first scalar is not less than or nearly equal to a second, could be though of as operator&gt;~. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_0</td><td>The first scalar value, s_0, to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_1</td><td>The second scalar value, s_1, to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance_relative</td><td>Tolerance value, tol_rel, below which two the normalised scalars are considered equal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance_absolute</td><td>Cutoff tolerance value, tol_abs, below which two the scalars are considered equal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the s_0 &gt; s_1 and s_0 !~= s_1, i.e. s_0 !&lt;=~ s_1.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not give a strictly greater than operation, it is designed to give consistent/continuous results between with is_nearly_less_equal. i.e. If is_nearly_less_equal(s_0, s_1) returns true this function will return false, and via versa if is_nearly_less_equal(s_0, s_1) returns false. This occurs even if the first scalar, s_0, is actually greater than the second, s_1. For this reason there is also no test for it, as is_nearly_less_equal is tested. </dd></dl>

</div>
</div>
<a id="ac79b4c22b2251a16b4ce10ab35754083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79b4c22b2251a16b4ce10ab35754083">&#9670;&nbsp;</a></span>is_nearly_greater_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Disa::is_nearly_greater_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance_relative</em> = <code><a class="el" href="namespace_disa.html#acbf188d2f52238f11ae72c35ff61d996">default_relative</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance_absolute</em> = <code><a class="el" href="namespace_disa.html#a0f0e38acec7e979eee6eaddf423d93b7">default_absolute</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a first scalar is greater than or nearly equal to a second, could be though of as operator&gt;=~. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_0</td><td>The first scalar value, s_0, to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_1</td><td>The second scalar value, s_1, to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance_relative</td><td>Tolerance value, tol_rel, below which two the normalised scalars are considered equal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance_absolute</td><td>Cutoff tolerance value, tol_abs, below which two the scalars are considered equal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the s_0 &gt; s_1 or s_0 ~= s_1, i.e. s_0 &gt;=~ s_1. </dd></dl>

</div>
</div>
<a id="ac30c55fc1693e9407d06d204a86b28aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30c55fc1693e9407d06d204a86b28aa">&#9670;&nbsp;</a></span>is_nearly_less()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Disa::is_nearly_less </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance_relative</em> = <code><a class="el" href="namespace_disa.html#acbf188d2f52238f11ae72c35ff61d996">default_relative</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance_absolute</em> = <code><a class="el" href="namespace_disa.html#a0f0e38acec7e979eee6eaddf423d93b7">default_absolute</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a first scalar is not greater than or nearly equal to a second, could be though of as operator&lt;~. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_0</td><td>The first scalar value, s_0, to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_1</td><td>The second scalar value, s_1, to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance_relative</td><td>Tolerance value, tol_rel, below which two the normalised scalars are considered equal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance_absolute</td><td>Cutoff tolerance value, tol_abs, below which two the scalars are considered equal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the s_0 &lt; s_1 and s_0 !~= s_1, i.e. s_0 !&gt;=~ s_1.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not give a strictly less than operation, it is designed to give consistent/continuous results between with is_nearly_greater_equal. i.e. If is_nearly_greater_equal(s_0, s_1) returns true this function will return false, and via versa if is_nearly_greater_equal(s_0, s_1) returns false. This occurs even if the first scalar, s_0, is actually less than the second, s_1. For this reason there is also no test for it, as is_nearly_greater_equal is tested. </dd></dl>

</div>
</div>
<a id="a169f81a587880e04bd2bab802b3de310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169f81a587880e04bd2bab802b3de310">&#9670;&nbsp;</a></span>is_nearly_less_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Disa::is_nearly_less_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance_relative</em> = <code><a class="el" href="namespace_disa.html#acbf188d2f52238f11ae72c35ff61d996">default_relative</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance_absolute</em> = <code><a class="el" href="namespace_disa.html#a0f0e38acec7e979eee6eaddf423d93b7">default_absolute</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a first scalar is less than or nearly equal to a second, could be though of as operator&lt;=~. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_0</td><td>The first scalar value, s_0, to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_1</td><td>The second scalar value, s_1, to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance_relative</td><td>Tolerance value, tol_rel, below which two the normalised scalars are considered equal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance_absolute</td><td>Cutoff tolerance value, tol_abs, below which two the scalars are considered equal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the s_0 &lt; s_1 or s_0 ~= s_1, i.e. s_0 &lt;=~ s_1. </dd></dl>

</div>
</div>
<a id="a4c59e5dc83aa26fafaf230ad9a29aeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c59e5dc83aa26fafaf230ad9a29aeed">&#9670;&nbsp;</a></span>level_expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Disa::level_expansion </td>
          <td>(</td>
          <td class="paramtype">const _graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a level-set expansion to color a parsed graph from a set of seed vertices, where the color of each vertex is associated with the 'closest' seed vertex. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_graph</td><td>The type of the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph on which level expansion is to be performed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seeds</td><td>Indices of seed vertices from which expansion will occur (No. colors = size of this vector). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertex_color</td><td>Of graph vertex size, and containing the color of each vertex after the level expansion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a946a4aa8be66636850f22969a357d6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946a4aa8be66636850f22969a357d6e3">&#9670;&nbsp;</a></span>level_traversal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; Disa::level_traversal </td>
          <td>(</td>
          <td class="paramtype">const _graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end_level</em> = <code>std::numeric_limits&lt;std::size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs level traversal on a given graph starting from a specified vertex and returns a vector that stores the level of each vertex. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_graph</td><td>The type of the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph on which level traversal is to be performed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_start</td><td>The vertex from which level traversal is to start. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_level</td><td>The maximum level to be considered during traversal (default is maximum value of std::size_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector that stores the level of each vertex after level traversal. </dd></dl>

</div>
</div>
<a id="a09ac38de58fda28f083fe8865879e00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ac38de58fda28f083fe8865879e00a">&#9670;&nbsp;</a></span>level_traversal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Disa::level_traversal </td>
          <td>(</td>
          <td class="paramtype">const _graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>end_level</em> = <code>std::numeric_limits&lt;std::size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform level traversal on a given graph starting from a given vertex queue and stores the level of each vertex in a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_graph</td><td>The type of the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph on which level traversal is to be performed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_queue</td><td>The queue of vertices from which level traversal is to start. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertex_level</td><td>A vector to store the level of each vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_level</td><td>The maximum level to be considered during traversal (default is maximum value of std::size_t). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25010854ded53d844e16d8159ea09810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25010854ded53d844e16d8159ea09810">&#9670;&nbsp;</a></span>lp_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> Disa::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the $L_p$-norm of a parsed vector, <img class="formulaInl" alt="$L_p = (\sum_i |a_i|^p)^1/p$" src="form_0.png"/>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_p_value</td><td>the p value for the norm, if 0 the l_infinity norm is computed. </td></tr>
    <tr><td class="paramname">_size</td><td>Size of the vector if static, else 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>The vector for which the norm is being computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed L_p-norm. </dd></dl>

</div>
</div>
<a id="a45c8821e9fe8741e3ede58b43aff5056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c8821e9fe8741e3ede58b43aff5056">&#9670;&nbsp;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> Disa::mean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the arithmetic mean of the vector's elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_size</td><td>Size of the vector if static, else 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vector</td><td>The vector to compute the mean value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arithmetic mean value of the vector. </dd></dl>

</div>
</div>
<a id="abd7ebf3a6a58690fea1530419eeac71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7ebf3a6a58690fea1530419eeac71c">&#9670;&nbsp;</a></span>multinode_level_set_expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void multinode_level_set_expansion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>max_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs level set expansion on subgraphs to partition a graph, requires an initial partitioning. </p>
<p>This function performs multinode level set expansion on a set of input subgraphs to 'improve' partition topology. The number of output subgraphs is thus the same as the number of input subgraphs. The method works by first computing the global eccentricity of the input graph. Nucleation seed vertices are then selected for each subgraph by finding the vertex with the minimum maximal eccentricity in each subgraph. From the nucleation sites a level set expansion is performed to create the next iteration of partitions. The process is repeated for the given number of iterations or until the seed vertices do not change between iterations. Once the function returns the update partition will be contained within the subgraph_list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph to partition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>The number of iterations to perform. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">subgraph_list</td><td>The list of initial subgraphs, and on completion, the final partitioning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada6a836107e9306bad16bfde83210c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6a836107e9306bad16bfde83210c29">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size&gt; Disa::operator* </td>
          <td>(</td>
          <td class="paramtype">const _type &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a vector by a scalar, c = b*a, where a, and c are vectors and b is a scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_vector</td><td>Vector type, dynamic/static. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value, b, to multiply the vector by. </td></tr>
    <tr><td class="paramname">vector</td><td>Vector, a, to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New vector (c). </dd></dl>

</div>
</div>
<a id="ae4c8e0d311dc2db38732db8d7362a01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c8e0d311dc2db38732db8d7362a01e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt;<a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _row&gt;, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size&gt; &gt;::type Disa::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row, _col &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a matrix and vector, c = A*b, where A is a matrix and c and b are vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_type</td><td>The type of the matrix, e.g. double, float, int. </td></tr>
    <tr><td class="paramname">_row</td><td>The number of rows of the A matrix, dynamic/static. </td></tr>
    <tr><td class="paramname">_col</td><td>The number of column of the A matrix, dynamic/static. </td></tr>
    <tr><td class="paramname">_size</td><td>The number of column of the A matrix, dynamic/static. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The matrix, A, to be multiplied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vector</td><td>The vector, b, to multiply the matrix by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New vector, c. </dd></dl>

</div>
</div>
<a id="aa73672d307ce64b3565cddc5da2a92cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73672d307ce64b3565cddc5da2a92cf">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_disa_1_1_matrix___static___demoter.html">Matrix_Static_Demoter</a>&lt;const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt;_type, _row_0, _col_0&gt;, const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt;_type, _row_1, _col_1&gt; &gt;::type Disa::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_0, _col_0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_1, _col_1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiples two matrices together, C = A*B, where A, B, and C are matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_type</td><td>The type of the matrix, e.g. double, float, int. </td></tr>
    <tr><td class="paramname">_row_0</td><td>The number of rows of the A matrix, dynamic/static. </td></tr>
    <tr><td class="paramname">_col_0</td><td>The number of column of the A matrix, dynamic/static. </td></tr>
    <tr><td class="paramname">_row_1</td><td>The number of rows of the B matrix, dynamic/static. </td></tr>
    <tr><td class="paramname">_col_1</td><td>The number of column of the B matrix, dynamic/static. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_0</td><td>The left matrix, A, to multiply. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_1</td><td>The right matrix, B, to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New matrix, C. </dd></dl>

</div>
</div>
<a id="a8bad92e4006dd16d1ac6b6149e647ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bad92e4006dd16d1ac6b6149e647ff4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, _size&gt; Disa::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>, _size &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies a sparse matrix and vector, c = A*b, where A is a sparse matrix and c and b are vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_size</td><td>The number of column of the A matrix, dynamic/static. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The sparse matrix, A, to be multiplied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vector</td><td>The vector, b, to multiply the matrix by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New vector, c.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>at present for static vectors the matrix must be square. </dd></dl>

</div>
</div>
<a id="a3907d6a33ce44e218aa2e45651d6cc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3907d6a33ce44e218aa2e45651d6cc02">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt;_type, _row, _col&gt; Disa::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row, _col &gt;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a matrix by a scalar, C = b*A, where A, and C are matrices and b is a scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_type</td><td>The type of the matrix, e.g. double, float, int. </td></tr>
    <tr><td class="paramname">_row</td><td>The number of rows of the A matrix, dynamic/static. </td></tr>
    <tr><td class="paramname">_col</td><td>The number of column of the A matrix, dynamic/static. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The scalar value, b, to multiply the matrix by. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The matrix, A, to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New matrix, C. </dd></dl>

</div>
</div>
<a id="af509d324b0288be3dd64abb559e35e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af509d324b0288be3dd64abb559e35e23">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> Disa::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a>&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a sparse matrix by a scalar, C = b*A, where A, and C are matrices and b is a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The scalar value, b, to multiply the matrix by. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The sparse matrix, A, to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New sparse matrix, C. </dd></dl>

</div>
</div>
<a id="a4ef2ba6a0c7cefc2c527b386d901ed2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef2ba6a0c7cefc2c527b386d901ed2e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> Disa::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a>&#160;</td>
          <td class="paramname"><em>matrix_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiples two sparse matrices together, C = A*B, where A, B, and C are sparse matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_0</td><td>The left sparse matrix, A, to multiply. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_1</td><td>The right sparse matrix, B, to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New sparse matrix, C. </dd></dl>

</div>
</div>
<a id="acd877c06bd6db306d864f4f64ef274ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd877c06bd6db306d864f4f64ef274ea">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt;<a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt;_type, _row_0, _col_0&gt;, <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt;_type, _row_1, _col_1&gt; &gt;::type Disa::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_0, _col_0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_1, _col_1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two matrices together, C = A + B, where A, B, and C are matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_type</td><td>The type of the matrix, e.g. double, float, int. </td></tr>
    <tr><td class="paramname">_row_0</td><td>The number of rows of the A matrix, dynamic/static. </td></tr>
    <tr><td class="paramname">_col_0</td><td>The number of column of the A matrix, dynamic/static. </td></tr>
    <tr><td class="paramname">_row_1</td><td>The number of rows of the B matrix, dynamic/static. </td></tr>
    <tr><td class="paramname">_col_1</td><td>The number of column of the B matrix, dynamic/static. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_0</td><td>The first matrix, A, to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_1</td><td>The second matrix, B, to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New matrix, C. </dd></dl>

</div>
</div>
<a id="a1b46bad9b3703cbf6bc8cb54fde0325b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b46bad9b3703cbf6bc8cb54fde0325b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt;<a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size_0&gt;, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size_1&gt; &gt;::type Disa::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two vectors together, c = a + b, where a, b, and c are vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_vector0</td><td>Vector type, dynamic/static, of a. </td></tr>
    <tr><td class="paramname">_vector1</td><td>Vector type, dynamic/static, of b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector0</td><td>The first vector of the addition, a. </td></tr>
    <tr><td class="paramname">vector1</td><td>The second vector of the addition, b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly constructed vector c. </dd></dl>

</div>
</div>
<a id="aff24d51f9c4906a5d5a6cc8c4f4879b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff24d51f9c4906a5d5a6cc8c4f4879b8">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> Disa::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a>&#160;</td>
          <td class="paramname"><em>matrix_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two sparse matrices together, C = A + B, where A, B, and C are sparse matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_0</td><td>The first sparse matrix, A, to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_1</td><td>The second sparse matrix, B, to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New sparse matrix, C. </dd></dl>

</div>
</div>
<a id="ace9e590e3eb5fa801628482978f4abd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9e590e3eb5fa801628482978f4abd7">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt;<a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt;_type, _row_0, _col_0&gt;, <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt;_type, _row_1, _col_1&gt; &gt;::type Disa::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_0, _col_0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row_1, _col_1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts one matrix from another, C = A - B, where A, B, and C are matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_type</td><td>The type of the matrix, e.g. double, float, int. </td></tr>
    <tr><td class="paramname">_row_0</td><td>The number of rows of the A matrix, dynamic/static. </td></tr>
    <tr><td class="paramname">_col_0</td><td>The number of column of the A matrix, dynamic/static. </td></tr>
    <tr><td class="paramname">_row_1</td><td>The number of rows of the B matrix, dynamic/static. </td></tr>
    <tr><td class="paramname">_col_1</td><td>The number of column of the B matrix, dynamic/static. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_0</td><td>The matrix, A, to be subtracted from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_1</td><td>The matrix, B, to subtract by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New matrix, C. </dd></dl>

</div>
</div>
<a id="a6378b6629fce8f6a3fe635edb1c29d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6378b6629fce8f6a3fe635edb1c29d08">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt;<a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size_0&gt;, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size_1&gt; &gt;::type Disa::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts two vectors, c = a - b, where a, b, and c are vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_vector0</td><td>Vector type, dynamic/static, of a. </td></tr>
    <tr><td class="paramname">_vector1</td><td>Vector type, dynamic/static, of b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector0</td><td>The vector being subtracted from, a. </td></tr>
    <tr><td class="paramname">vector1</td><td>The subtracting vector, b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly constructed vector c. </dd></dl>

</div>
</div>
<a id="a73b5088e0d1932d3bf48f2186cbc59c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b5088e0d1932d3bf48f2186cbc59c5">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> Disa::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a>&#160;</td>
          <td class="paramname"><em>matrix_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts one sparse matrix from another, C = A - B, where A, B, and C are sparse matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_0</td><td>The sparse matrix, A, to be subtracted from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_1</td><td>The sparse matrix, B, to subtract by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New sparse matrix, C. </dd></dl>

</div>
</div>
<a id="a1013b883de71a12d538bd2ec65989b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1013b883de71a12d538bd2ec65989b5f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt;_type, _row, _col&gt; Disa::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_disa_1_1_matrix___dense.html">Matrix_Dense</a>&lt; _type, _row, _col &gt;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides a matrix by a scalar, C = A/b, where A, and C are matrices and b is a scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_type</td><td>The type of the matrix, e.g. double, float, int. </td></tr>
    <tr><td class="paramname">_row</td><td>The number of rows of the A matrix, dynamic/static. </td></tr>
    <tr><td class="paramname">_col</td><td>The number of column of the A matrix, dynamic/static. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The matrix, A, to be divided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The scalar value, b, to divide the matrix by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New matrix, C. </dd></dl>

</div>
</div>
<a id="a6d366a4065a104d047950a627bad4c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d366a4065a104d047950a627bad4c33">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> Disa::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a>&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides a sparse matrix by a scalar, C = A/b, where A, and C are sparse matrices and b is a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The sparse matrix, A, to be divided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The scalar value, b, to divide the matrix by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New sparse matrix, C. </dd></dl>

</div>
</div>
<a id="a19fe2e53ebf5be324189578cf9c01ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fe2e53ebf5be324189578cf9c01ad0">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size&gt; Disa::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _type &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides a vector by a scalar, c = b*a, where a, and c are vectors and b is a scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_vector</td><td>Vector type, dynamic/static. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value, b, to multiply the vector by. </td></tr>
    <tr><td class="paramname">vector</td><td>Vector, a, to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New vector (c). </dd></dl>

</div>
</div>
<a id="a2f3cad1511bda44d82010b22562a1517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3cad1511bda44d82010b22562a1517">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; _directed &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded stream operator for the out stream, writes out a formatted graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ostream</td><td>The out stream to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the ostream, with the graph writen out.</dd></dl>
<p>Outputs the subgraph data to 'screen', each vertex is printed, followed by its adjacent vertices. If the vertex adjacency is empty then a period is placed in the row.</p>
<p>The output format looks like: 1, 3 00, 1 </p>

</div>
</div>
<a id="ac66f762a69bdf0037319671a4d853cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66f762a69bdf0037319671a4d853cc8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded stream operator for the out stream, writes out a formatted graph. </p>
<p>Outputs the subgraph data to 'screen', each vertex is printed, followed by its adjacent vertices. If the vertex adjacency is empty then a period is placed in the row. Following this the local-to-global map is printed with the vertex level value placed in parenthesis.</p>
<p>The output format looks like: 1, 3 00, 1 0 -&gt; 165 (0) 1 -&gt; 154 (0) 2 -&gt; 161 (0) 2 -&gt; 150 (1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ostream</td><td>The out stream to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the ostream, with the graph writen out.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since there is no complete way to fully check if two graphs are identical, other than a brute force approach, this approach is 'lazy'. It picks out a few properties of the graph and combines them, in the hope that major topological changes will be caught. However it is possible to 'flip' and edge and for the hash to remain unchanged. </dd></dl>

</div>
</div>
<a id="abc9ac18476d94a7fb07a8ccbcd276327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9ac18476d94a7fb07a8ccbcd276327">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Disa::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_disa_1_1_matrix___sparse.html">Matrix_Sparse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output shift operator - to write to console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td>Stream object to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The sparse matrix to write out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inputted stream.</dd></dl>
<p>todo: properly format - this is just here to help occasional debugging. </p>

</div>
</div>
<a id="a5bf26006229af6790528099b84e91d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf26006229af6790528099b84e91d6c">&#9670;&nbsp;</a></span>order_edge_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt;const std::size_t&amp;, const std::size_t&amp;&gt; Disa::order_edge_vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a5d0458dbd92d3cbd94eddeb318b6d88f">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition of an edge, alias for a pair of unsigned ints. </p>
<p>Returns an ordered vertex list for an edge (without duplicated memory). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The edge to re_order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new 'edge', [reference to lower indexed vertex, reference to upper indexed vertex]. </dd></dl>

</div>
</div>
<a id="a83759d9ece7a6cba4e733b6e7dcb55fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83759d9ece7a6cba4e733b6e7dcb55fd">&#9670;&nbsp;</a></span>projection_orthogonal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt;<a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size_0&gt;, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size_1&gt; &gt;::type Disa::projection_orthogonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects a vector, a, such that the projection is orthogonal to a second vector, b. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_size_0</td><td>Size of the first vector if static, else 0. </td></tr>
    <tr><td class="paramname">_size_1</td><td>Size of the second vector if static, else 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vector_0</td><td>The vector to project. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vector_1</td><td>The 'orthogonal' direction of the projection, must be a unit vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The projected vector. </dd></dl>

</div>
</div>
<a id="a82a4f1ca2fdd273aab99b5ba3c0f9636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a4f1ca2fdd273aab99b5ba3c0f9636">&#9670;&nbsp;</a></span>projection_tangent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_disa_1_1_static___promoter.html">Static_Promoter</a>&lt;<a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size_0&gt;, <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size_1&gt; &gt;::type Disa::projection_tangent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size_1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects a vector, a, onto a second vector, b, i.e. </p>
<p>the component of a in the directory of b. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_size_0</td><td>Size of the first vector if static, else 0. </td></tr>
    <tr><td class="paramname">_size_1</td><td>Size of the second vector if static, else 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vector_0</td><td>The vector to project. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vector_1</td><td>The direction of the projection, must be a unit vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The projected vector. </dd></dl>

</div>
</div>
<a id="ad4545c645058204de6bd28e10681f9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4545c645058204de6bd28e10681f9a9">&#9670;&nbsp;</a></span>pseudo_peripheral_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Disa::pseudo_peripheral_vertex </td>
          <td>(</td>
          <td class="paramtype">const _graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i_start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a pseudo peripheral vertex in the parsed graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_graph</td><td>The type of the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>A non-empty graph to search for a peripheral vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_start</td><td>Because the algorithm is path dependent a starting vertex can be specified, defaults to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of te pseudo peripheral vertex. </dd></dl>

</div>
</div>
<a id="a9ccfdf59250250b0a6e5d66cea34909d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccfdf59250250b0a6e5d66cea34909d">&#9670;&nbsp;</a></span>recursive_graph_bisection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a> &gt; recursive_graph_bisection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a>&lt; false &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>number_partitions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively bisects a given graph into a specified number of subgraphs. </p>
<p>This function performs a recursive bisection of a graph into a specified number of partitions. It uses a level traversal to determine the level at which to split the subgraph with the largest number of vertices, which then forms two new subgraphs. This process is repeated, until the desired number of partitions is achieved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The original graph to be bisected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number_partitions</td><td>The number of subgraphs to be generated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of subgraphs representing the bisected graph. </dd></dl>

</div>
</div>
<a id="a31d4a639fc2b140b07ddb5d7b4b3f881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d4a639fc2b140b07ddb5d7b4b3f881">&#9670;&nbsp;</a></span>unit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt;_type, _size&gt; Disa::unit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_disa_1_1_vector___dense.html">Vector_Dense</a>&lt; _type, _size &gt;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a new vector with the same direction, but unit length. </p>
<p>Zero vectors are returned as zero vectors. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_size</td><td>Size of the vector if static, else 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vector</td><td>The vector to be normalised. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unit vector if the vector has size, else the zero vector. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0f0e38acec7e979eee6eaddf423d93b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0e38acec7e979eee6eaddf423d93b7">&#9670;&nbsp;</a></span>default_absolute</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> default_absolute = static_cast&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;(64)*<a class="el" href="namespace_disa.html#a7ba5e5cba5f93f1f374fde90b8004f33">scalar_epsilon</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global for default absolute equality check, 'reasonably over 2 orders of epsilon. </p>

</div>
</div>
<a id="acbf188d2f52238f11ae72c35ff61d996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf188d2f52238f11ae72c35ff61d996">&#9670;&nbsp;</a></span>default_relative</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> default_relative = static_cast&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;(65536)*<a class="el" href="namespace_disa.html#a7ba5e5cba5f93f1f374fde90b8004f33">scalar_epsilon</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global for default relative equality check, 'reasonably over 4 orders of epsilon. </p>

</div>
</div>
<a id="a7ba5e5cba5f93f1f374fde90b8004f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba5e5cba5f93f1f374fde90b8004f33">&#9670;&nbsp;</a></span>scalar_epsilon</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> scalar_epsilon = std::numeric_limits&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;::epsilon()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for scalar epsilon. </p>

</div>
</div>
<a id="af36831b38dd18e0850fdbf66cc411589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36831b38dd18e0850fdbf66cc411589">&#9670;&nbsp;</a></span>scalar_infinity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> scalar_infinity = std::numeric_limits&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;::infinity()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for scalar infinity. </p>

</div>
</div>
<a id="aaa4606e08e37c5f0788bed13690b590f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4606e08e37c5f0788bed13690b590f">&#9670;&nbsp;</a></span>scalar_lowest</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> scalar_lowest = std::numeric_limits&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;::lowest()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for scalar lowest. </p>

</div>
</div>
<a id="a02f0e41a0d2a61294284a230df8dde39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f0e41a0d2a61294284a230df8dde39">&#9670;&nbsp;</a></span>scalar_max</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> scalar_max = std::numeric_limits&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for scalar max. </p>

</div>
</div>
<a id="a1c49faaab8fc3e11899afcaf065ebd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c49faaab8fc3e11899afcaf065ebd1d">&#9670;&nbsp;</a></span>scalar_max_digits10</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> scalar_max_digits10 = std::numeric_limits&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;::max_digits10</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for scalar max_digits10. </p>

</div>
</div>
<a id="a12f2f0b7a88ef69ff7f5b3d4b6d7a7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f2f0b7a88ef69ff7f5b3d4b6d7a7ac">&#9670;&nbsp;</a></span>scalar_min</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a> scalar_min = std::numeric_limits&lt;<a class="el" href="namespace_disa.html#a8c2981f3f834be9448a6ab06c28748eb">Scalar</a>&gt;::min()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for scalar min. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_disa.html">Disa</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
