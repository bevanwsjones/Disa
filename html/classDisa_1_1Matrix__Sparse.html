<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Disa: Disa::Matrix_Sparse Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Disa
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Disa</b></li><li class="navelem"><a class="el" href="classDisa_1_1Matrix__Sparse.html">Matrix_Sparse</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classDisa_1_1Matrix__Sparse-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Disa::Matrix_Sparse Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A efficient data structure which represents a matrix comprised of mostly zero entries. Follows compact storage row (CSR) approach.  
 <a href="classDisa_1_1Matrix__Sparse.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="matrix__sparse_8h_source.html">matrix_sparse.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1084799691795b304d0eb1359e7595b2"><td class="memItemLeft" align="right" valign="top"><a id="a1084799691795b304d0eb1359e7595b2" name="a1084799691795b304d0eb1359e7595b2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>matrix</b> = <a class="el" href="classDisa_1_1Matrix__Sparse.html">Matrix_Sparse</a></td></tr>
<tr class="separator:a1084799691795b304d0eb1359e7595b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d40a2c2d41c2257cd9d4fca1523834e"><td class="memItemLeft" align="right" valign="top"><a id="a1d40a2c2d41c2257cd9d4fca1523834e" name="a1d40a2c2d41c2257cd9d4fca1523834e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">Iterator_Matrix_Sparse_Row</a>&lt; <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &gt;</td></tr>
<tr class="separator:a1d40a2c2d41c2257cd9d4fca1523834e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e848cf0fb558c98565917f69ef6a564"><td class="memItemLeft" align="right" valign="top"><a id="a6e848cf0fb558c98565917f69ef6a564" name="a6e848cf0fb558c98565917f69ef6a564"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">Iterator_Matrix_Sparse_Row</a>&lt; const <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &gt;</td></tr>
<tr class="separator:a6e848cf0fb558c98565917f69ef6a564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4e34ef357af2042210f13d80cf78df"><td class="memItemLeft" align="right" valign="top"><a id="aee4e34ef357af2042210f13d80cf78df" name="aee4e34ef357af2042210f13d80cf78df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_element</b> = <a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">Iterator_Matrix_Sparse_Element</a>&lt; <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &gt;</td></tr>
<tr class="separator:aee4e34ef357af2042210f13d80cf78df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab684b20d3aa301ae9415a7a339f6079f"><td class="memItemLeft" align="right" valign="top"><a id="ab684b20d3aa301ae9415a7a339f6079f" name="ab684b20d3aa301ae9415a7a339f6079f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator_element</b> = <a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">Iterator_Matrix_Sparse_Element</a>&lt; const <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &gt;</td></tr>
<tr class="separator:ab684b20d3aa301ae9415a7a339f6079f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a746c43a0df4f6c969cb2775c419d7e2d"><td class="memItemLeft" align="right" valign="top"><a id="a746c43a0df4f6c969cb2775c419d7e2d" name="a746c43a0df4f6c969cb2775c419d7e2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix_Sparse</b> ()=default</td></tr>
<tr class="memdesc:a746c43a0df4f6c969cb2775c419d7e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a746c43a0df4f6c969cb2775c419d7e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa382150da0d7ea1b72bc06ed219215a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#aa382150da0d7ea1b72bc06ed219215a3">Matrix_Sparse</a> (std::size_t row, std::size_t column)</td></tr>
<tr class="memdesc:aa382150da0d7ea1b72bc06ed219215a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sparse matrix with a set number of rows and columns.  <a href="classDisa_1_1Matrix__Sparse.html#aa382150da0d7ea1b72bc06ed219215a3">More...</a><br /></td></tr>
<tr class="separator:aa382150da0d7ea1b72bc06ed219215a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cff83464b43fe9569f140e9a1130d6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a0cff83464b43fe9569f140e9a1130d6b">Matrix_Sparse</a> (std::initializer_list&lt; std::size_t &gt; non_zero, std::initializer_list&lt; std::size_t &gt; index, std::initializer_list&lt; Scalar &gt; value, std::size_t column)</td></tr>
<tr class="memdesc:a0cff83464b43fe9569f140e9a1130d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list based on the 'raw' data structure of a sparse matrix.  <a href="classDisa_1_1Matrix__Sparse.html#a0cff83464b43fe9569f140e9a1130d6b">More...</a><br /></td></tr>
<tr class="separator:a0cff83464b43fe9569f140e9a1130d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10098fd0bfc69d30fd406c8f97dc262"><td class="memItemLeft" align="right" valign="top"><a id="aa10098fd0bfc69d30fd406c8f97dc262" name="aa10098fd0bfc69d30fd406c8f97dc262"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Matrix_Sparse</b> ()=default</td></tr>
<tr class="memdesc:aa10098fd0bfc69d30fd406c8f97dc262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:aa10098fd0bfc69d30fd406c8f97dc262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e9352bab07ef7ed4780f2c1041bf59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#ae5e9352bab07ef7ed4780f2c1041bf59">operator=</a> (const <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;other)=default</td></tr>
<tr class="memdesc:ae5e9352bab07ef7ed4780f2c1041bf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a trivial deep copy of the assigned matrix.  <a href="classDisa_1_1Matrix__Sparse.html#ae5e9352bab07ef7ed4780f2c1041bf59">More...</a><br /></td></tr>
<tr class="separator:ae5e9352bab07ef7ed4780f2c1041bf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b8307cbd125de4afe193208a9168b0"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a91b8307cbd125de4afe193208a9168b0">at</a> (const std::size_t &amp;i_row, const std::size_t &amp;i_column)</td></tr>
<tr class="memdesc:a91b8307cbd125de4afe193208a9168b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access specified element with bounds checking.  <a href="classDisa_1_1Matrix__Sparse.html#a91b8307cbd125de4afe193208a9168b0">More...</a><br /></td></tr>
<tr class="separator:a91b8307cbd125de4afe193208a9168b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0a1744629534509e385c1e0edc1135"><td class="memItemLeft" align="right" valign="top">const Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a8d0a1744629534509e385c1e0edc1135">at</a> (const std::size_t &amp;i_row, const std::size_t &amp;i_column) const</td></tr>
<tr class="memdesc:a8d0a1744629534509e385c1e0edc1135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access specified element with bounds checking.  <a href="classDisa_1_1Matrix__Sparse.html#a8d0a1744629534509e385c1e0edc1135">More...</a><br /></td></tr>
<tr class="separator:a8d0a1744629534509e385c1e0edc1135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd6f303a93389d16e069cf7c1493952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDisa_1_1Matrix__Sparse__Row.html">Matrix_Sparse_Row</a>&lt; <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a4dd6f303a93389d16e069cf7c1493952">operator[]</a> (const std::size_t &amp;i_row)</td></tr>
<tr class="memdesc:a4dd6f303a93389d16e069cf7c1493952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for access to a specified matrix row.  <a href="classDisa_1_1Matrix__Sparse.html#a4dd6f303a93389d16e069cf7c1493952">More...</a><br /></td></tr>
<tr class="separator:a4dd6f303a93389d16e069cf7c1493952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2c0e3d3e20e46f5230f7485ff37d82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDisa_1_1Matrix__Sparse__Row.html">Matrix_Sparse_Row</a>&lt; const <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#acf2c0e3d3e20e46f5230f7485ff37d82">operator[]</a> (const std::size_t &amp;i_row) const</td></tr>
<tr class="memdesc:acf2c0e3d3e20e46f5230f7485ff37d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for access to a specified matrix row.  <a href="classDisa_1_1Matrix__Sparse.html#acf2c0e3d3e20e46f5230f7485ff37d82">More...</a><br /></td></tr>
<tr class="separator:acf2c0e3d3e20e46f5230f7485ff37d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191b6c57c900c92e9eeeb06dd959704d"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::size_t *, std::size_t *, Scalar * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a191b6c57c900c92e9eeeb06dd959704d">data</a> () noexcept</td></tr>
<tr class="memdesc:a191b6c57c900c92e9eeeb06dd959704d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDisa_1_1Direct.html" title="Direct Dense Linear Solver Base Class.">Direct</a> access to the underlying array of the sparse matrix.  <a href="classDisa_1_1Matrix__Sparse.html#a191b6c57c900c92e9eeeb06dd959704d">More...</a><br /></td></tr>
<tr class="separator:a191b6c57c900c92e9eeeb06dd959704d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbfaa8f2d019ac0cdc544209da88dea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#acbbfaa8f2d019ac0cdc544209da88dea">begin</a> () noexcept</td></tr>
<tr class="memdesc:acbbfaa8f2d019ac0cdc544209da88dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning row of the matrix.  <a href="classDisa_1_1Matrix__Sparse.html#acbbfaa8f2d019ac0cdc544209da88dea">More...</a><br /></td></tr>
<tr class="separator:acbbfaa8f2d019ac0cdc544209da88dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac469863648160c38e3c56e7d81a7ae0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#ac469863648160c38e3c56e7d81a7ae0e">begin</a> () const noexcept</td></tr>
<tr class="memdesc:ac469863648160c38e3c56e7d81a7ae0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the beginning row of the matrix.  <a href="classDisa_1_1Matrix__Sparse.html#ac469863648160c38e3c56e7d81a7ae0e">More...</a><br /></td></tr>
<tr class="separator:ac469863648160c38e3c56e7d81a7ae0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46849cea10ff98c6bc40713ae4fbb58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#ae46849cea10ff98c6bc40713ae4fbb58">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:ae46849cea10ff98c6bc40713ae4fbb58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the beginning row of the matrix.  <a href="classDisa_1_1Matrix__Sparse.html#ae46849cea10ff98c6bc40713ae4fbb58">More...</a><br /></td></tr>
<tr class="separator:ae46849cea10ff98c6bc40713ae4fbb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c17a55f0b505c9e8a84898b98d6c9df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df">end</a> () noexcept</td></tr>
<tr class="memdesc:a1c17a55f0b505c9e8a84898b98d6c9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.  <a href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df">More...</a><br /></td></tr>
<tr class="separator:a1c17a55f0b505c9e8a84898b98d6c9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca05793b24448cf4e9552eade5ab477c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#aca05793b24448cf4e9552eade5ab477c">end</a> () const noexcept</td></tr>
<tr class="memdesc:aca05793b24448cf4e9552eade5ab477c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the end row (i.e. 1 past the last row) of the matrix.  <a href="classDisa_1_1Matrix__Sparse.html#aca05793b24448cf4e9552eade5ab477c">More...</a><br /></td></tr>
<tr class="separator:aca05793b24448cf4e9552eade5ab477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8a3f9795d9dab326cd45755c8fda09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#aab8a3f9795d9dab326cd45755c8fda09">cend</a> () const noexcept</td></tr>
<tr class="memdesc:aab8a3f9795d9dab326cd45755c8fda09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the end row (i.e. 1 past the last row) of the matrix.  <a href="classDisa_1_1Matrix__Sparse.html#aab8a3f9795d9dab326cd45755c8fda09">More...</a><br /></td></tr>
<tr class="separator:aab8a3f9795d9dab326cd45755c8fda09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707bc4a0afb01e76a9afa98226d6c1f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a707bc4a0afb01e76a9afa98226d6c1f9">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a707bc4a0afb01e76a9afa98226d6c1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the matrix is empty. An empty matrix is considered where the number of rows is 0.  <a href="classDisa_1_1Matrix__Sparse.html#a707bc4a0afb01e76a9afa98226d6c1f9">More...</a><br /></td></tr>
<tr class="separator:a707bc4a0afb01e76a9afa98226d6c1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e20cba0ddb4dcde4d02058168b50cdc"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a2e20cba0ddb4dcde4d02058168b50cdc">size_row</a> () const noexcept</td></tr>
<tr class="memdesc:a2e20cba0ddb4dcde4d02058168b50cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in the matrix.  <a href="classDisa_1_1Matrix__Sparse.html#a2e20cba0ddb4dcde4d02058168b50cdc">More...</a><br /></td></tr>
<tr class="separator:a2e20cba0ddb4dcde4d02058168b50cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3a2fd59ab0ffc8b2911ebf4465e377"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#aed3a2fd59ab0ffc8b2911ebf4465e377">size_column</a> () const noexcept</td></tr>
<tr class="memdesc:aed3a2fd59ab0ffc8b2911ebf4465e377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the matrix.  <a href="classDisa_1_1Matrix__Sparse.html#aed3a2fd59ab0ffc8b2911ebf4465e377">More...</a><br /></td></tr>
<tr class="separator:aed3a2fd59ab0ffc8b2911ebf4465e377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f3cba86a8796d8996b2d401410550e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a23f3cba86a8796d8996b2d401410550e">size_non_zero</a> () const noexcept</td></tr>
<tr class="memdesc:a23f3cba86a8796d8996b2d401410550e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zeros in the matrix.  <a href="classDisa_1_1Matrix__Sparse.html#a23f3cba86a8796d8996b2d401410550e">More...</a><br /></td></tr>
<tr class="separator:a23f3cba86a8796d8996b2d401410550e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc017a21bb48701c6d7fd3fd1e74d76"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a6bc017a21bb48701c6d7fd3fd1e74d76">size</a> () const noexcept</td></tr>
<tr class="memdesc:a6bc017a21bb48701c6d7fd3fd1e74d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows and columns in the matrix. If rows are 0, columns are 0.  <a href="classDisa_1_1Matrix__Sparse.html#a6bc017a21bb48701c6d7fd3fd1e74d76">More...</a><br /></td></tr>
<tr class="separator:a6bc017a21bb48701c6d7fd3fd1e74d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2ca51fadda30ae1963f861d2aaa3b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#abb2ca51fadda30ae1963f861d2aaa3b4">reserve</a> (const std::size_t &amp;row, const std::size_t &amp;non_zero) noexcept</td></tr>
<tr class="memdesc:abb2ca51fadda30ae1963f861d2aaa3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves storage for the matrix.  <a href="classDisa_1_1Matrix__Sparse.html#abb2ca51fadda30ae1963f861d2aaa3b4">More...</a><br /></td></tr>
<tr class="separator:abb2ca51fadda30ae1963f861d2aaa3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf098c5c8afd5683405c9c3dd05b664"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a7cf098c5c8afd5683405c9c3dd05b664">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a7cf098c5c8afd5683405c9c3dd05b664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of row offsets and non-zeros entries that can be held in currently allocated storage.  <a href="classDisa_1_1Matrix__Sparse.html#a7cf098c5c8afd5683405c9c3dd05b664">More...</a><br /></td></tr>
<tr class="separator:a7cf098c5c8afd5683405c9c3dd05b664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585fdf3e065bf35ba5d4f786b4b4d531"><td class="memItemLeft" align="right" valign="top"><a id="a585fdf3e065bf35ba5d4f786b4b4d531" name="a585fdf3e065bf35ba5d4f786b4b4d531"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrink_to_fit</b> () noexcept</td></tr>
<tr class="memdesc:a585fdf3e065bf35ba5d4f786b4b4d531"><td class="mdescLeft">&#160;</td><td class="mdescRight">reduces memory usage by the matrix by freeing unused memory for both rows and non-zeros <br /></td></tr>
<tr class="separator:a585fdf3e065bf35ba5d4f786b4b4d531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2df61b470b5f35b4f1852e7d0cb683"><td class="memItemLeft" align="right" valign="top"><a id="a6d2df61b470b5f35b4f1852e7d0cb683" name="a6d2df61b470b5f35b4f1852e7d0cb683"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> () noexcept</td></tr>
<tr class="memdesc:a6d2df61b470b5f35b4f1852e7d0cb683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the contents of the matrix, sets the column size to zero. <br /></td></tr>
<tr class="separator:a6d2df61b470b5f35b4f1852e7d0cb683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db3c11fd4d31fd9b3f7754f3954bccd"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">iterator_element</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a1db3c11fd4d31fd9b3f7754f3954bccd">insert</a> (const std::size_t &amp;i_row, const std::size_t &amp;i_column, const Scalar &amp;value)</td></tr>
<tr class="memdesc:a1db3c11fd4d31fd9b3f7754f3954bccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an value with the parsed value at [i_row, i_column], if an value exists nothing occurs.  <a href="classDisa_1_1Matrix__Sparse.html#a1db3c11fd4d31fd9b3f7754f3954bccd">More...</a><br /></td></tr>
<tr class="separator:a1db3c11fd4d31fd9b3f7754f3954bccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f048f42cc4229c9ceb47d42557aa185"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">iterator_element</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a3f048f42cc4229c9ceb47d42557aa185">insert_or_assign</a> (const std::size_t &amp;i_row, const std::size_t &amp;i_column, const Scalar &amp;value)</td></tr>
<tr class="memdesc:a3f048f42cc4229c9ceb47d42557aa185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts or updates an value with the parsed value at [i_row, i_column].  <a href="classDisa_1_1Matrix__Sparse.html#a3f048f42cc4229c9ceb47d42557aa185">More...</a><br /></td></tr>
<tr class="separator:a3f048f42cc4229c9ceb47d42557aa185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6679eaabb10d4be6a5e0d85ebcc9b97e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">iterator_element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a6679eaabb10d4be6a5e0d85ebcc9b97e">erase</a> (const <a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">Iterator_Matrix_Sparse_Element</a>&lt; <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &gt; &amp;iter_element)</td></tr>
<tr class="memdesc:a6679eaabb10d4be6a5e0d85ebcc9b97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a value at the specified row and column, using an element iterator.  <a href="classDisa_1_1Matrix__Sparse.html#a6679eaabb10d4be6a5e0d85ebcc9b97e">More...</a><br /></td></tr>
<tr class="separator:a6679eaabb10d4be6a5e0d85ebcc9b97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbed30634d3e1b28566c2581af03896"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a8cbed30634d3e1b28566c2581af03896">resize</a> (const std::size_t &amp;row, const std::size_t &amp;column)</td></tr>
<tr class="memdesc:a8cbed30634d3e1b28566c2581af03896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the number of rows and columns of the matrix.  <a href="classDisa_1_1Matrix__Sparse.html#a8cbed30634d3e1b28566c2581af03896">More...</a><br /></td></tr>
<tr class="separator:a8cbed30634d3e1b28566c2581af03896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9167eef9bae2398d3857db8b68b79dfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a9167eef9bae2398d3857db8b68b79dfb">swap</a> (<a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a9167eef9bae2398d3857db8b68b79dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the matrix with the parsed matrix.  <a href="classDisa_1_1Matrix__Sparse.html#a9167eef9bae2398d3857db8b68b79dfb">More...</a><br /></td></tr>
<tr class="separator:a9167eef9bae2398d3857db8b68b79dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ad3d410781a3f505a4d2cf0dcb997e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">iterator_element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#ac8ad3d410781a3f505a4d2cf0dcb997e">find</a> (const std::size_t &amp;i_row, const std::size_t &amp;i_column)</td></tr>
<tr class="memdesc:ac8ad3d410781a3f505a4d2cf0dcb997e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the value iterator to the matrix value at a row and column.  <a href="classDisa_1_1Matrix__Sparse.html#ac8ad3d410781a3f505a4d2cf0dcb997e">More...</a><br /></td></tr>
<tr class="separator:ac8ad3d410781a3f505a4d2cf0dcb997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae893703db2a63335c1f43c3be08bc687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">const_iterator_element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#ae893703db2a63335c1f43c3be08bc687">find</a> (const std::size_t &amp;i_row, const std::size_t &amp;i_column) const</td></tr>
<tr class="memdesc:ae893703db2a63335c1f43c3be08bc687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the value iterator to the matrix value at a row and column.  <a href="classDisa_1_1Matrix__Sparse.html#ae893703db2a63335c1f43c3be08bc687">More...</a><br /></td></tr>
<tr class="separator:ae893703db2a63335c1f43c3be08bc687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5937c136cd9f470c56dc431e7d1e21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#aca5937c136cd9f470c56dc431e7d1e21">contains</a> (const std::size_t &amp;i_row, const std::size_t &amp;i_column) const</td></tr>
<tr class="memdesc:aca5937c136cd9f470c56dc431e7d1e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the element at a row and column are non-zero.  <a href="classDisa_1_1Matrix__Sparse.html#aca5937c136cd9f470c56dc431e7d1e21">More...</a><br /></td></tr>
<tr class="separator:aca5937c136cd9f470c56dc431e7d1e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac457fb034cdd0ca3b1f732cd76354ead"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">iterator_element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#ac457fb034cdd0ca3b1f732cd76354ead">lower_bound</a> (const std::size_t &amp;i_row, const std::size_t &amp;i_column)</td></tr>
<tr class="memdesc:ac457fb034cdd0ca3b1f732cd76354ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an element iterator to the first element not less than the given key.  <a href="classDisa_1_1Matrix__Sparse.html#ac457fb034cdd0ca3b1f732cd76354ead">More...</a><br /></td></tr>
<tr class="separator:ac457fb034cdd0ca3b1f732cd76354ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77685121fab9302dd42f0f0ad6c4e63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">const_iterator_element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#af77685121fab9302dd42f0f0ad6c4e63">lower_bound</a> (const std::size_t &amp;i_row, const std::size_t &amp;i_column) const</td></tr>
<tr class="memdesc:af77685121fab9302dd42f0f0ad6c4e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an element iterator to the first element not less than the given key.  <a href="classDisa_1_1Matrix__Sparse.html#af77685121fab9302dd42f0f0ad6c4e63">More...</a><br /></td></tr>
<tr class="separator:af77685121fab9302dd42f0f0ad6c4e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93839da27fad6a1162e34a6c72ec2af3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a93839da27fad6a1162e34a6c72ec2af3">operator*=</a> (const Scalar &amp;scalar)</td></tr>
<tr class="memdesc:a93839da27fad6a1162e34a6c72ec2af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the matrix by a scalar, A' = A*b, where A is the matrix and b is the scalar.  <a href="classDisa_1_1Matrix__Sparse.html#a93839da27fad6a1162e34a6c72ec2af3">More...</a><br /></td></tr>
<tr class="separator:a93839da27fad6a1162e34a6c72ec2af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ff1630e174662e2ad1c59aa303cc90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a43ff1630e174662e2ad1c59aa303cc90">operator/=</a> (const Scalar &amp;scalar)</td></tr>
<tr class="memdesc:a43ff1630e174662e2ad1c59aa303cc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the matrix by a scalar, A' = A/b, where A is the matrix and b is a scalar.  <a href="classDisa_1_1Matrix__Sparse.html#a43ff1630e174662e2ad1c59aa303cc90">More...</a><br /></td></tr>
<tr class="separator:a43ff1630e174662e2ad1c59aa303cc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8dc7d58ae426db3564805963be34f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a4d8dc7d58ae426db3564805963be34f6">operator+=</a> (const <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;other)</td></tr>
<tr class="memdesc:a4d8dc7d58ae426db3564805963be34f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a second matrix, A' = A + B, where A and B are matrices.  <a href="classDisa_1_1Matrix__Sparse.html#a4d8dc7d58ae426db3564805963be34f6">More...</a><br /></td></tr>
<tr class="separator:a4d8dc7d58ae426db3564805963be34f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f43906d741a4e699cefd53421f1d19e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a3f43906d741a4e699cefd53421f1d19e">operator-=</a> (const <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;other)</td></tr>
<tr class="memdesc:a3f43906d741a4e699cefd53421f1d19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction by a second matrix, A' = A - B, where A and B are matrices.  <a href="classDisa_1_1Matrix__Sparse.html#a3f43906d741a4e699cefd53421f1d19e">More...</a><br /></td></tr>
<tr class="separator:a3f43906d741a4e699cefd53421f1d19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124ba6fbcc1ca4f174fd6bef91bd3dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#a124ba6fbcc1ca4f174fd6bef91bd3dd3">operator*=</a> (const <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;other)</td></tr>
<tr class="memdesc:a124ba6fbcc1ca4f174fd6bef91bd3dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this matrix by another, A' = A*B, where A and B are matrices.  <a href="classDisa_1_1Matrix__Sparse.html#a124ba6fbcc1ca4f174fd6bef91bd3dd3">More...</a><br /></td></tr>
<tr class="separator:a124ba6fbcc1ca4f174fd6bef91bd3dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a41c4e3fa9135d804fb2888e7bfeb9f0e"><td class="memItemLeft" align="right" valign="top"><a id="a41c4e3fa9135d804fb2888e7bfeb9f0e" name="a41c4e3fa9135d804fb2888e7bfeb9f0e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix_Sparse_Row&lt; matrix &gt;</b></td></tr>
<tr class="separator:a41c4e3fa9135d804fb2888e7bfeb9f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89fccf341087359afc46b9f433623a9"><td class="memItemLeft" align="right" valign="top"><a id="ad89fccf341087359afc46b9f433623a9" name="ad89fccf341087359afc46b9f433623a9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix_Sparse_Row&lt; const matrix &gt;</b></td></tr>
<tr class="separator:ad89fccf341087359afc46b9f433623a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0790bcffa36816f5707b2912cd612e3"><td class="memItemLeft" align="right" valign="top"><a id="ae0790bcffa36816f5707b2912cd612e3" name="ae0790bcffa36816f5707b2912cd612e3"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>Iterator_Matrix_Sparse_Row&lt; matrix &gt;</b></td></tr>
<tr class="separator:ae0790bcffa36816f5707b2912cd612e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f0ba020da860e1f378766f6ad46f5d"><td class="memItemLeft" align="right" valign="top"><a id="a95f0ba020da860e1f378766f6ad46f5d" name="a95f0ba020da860e1f378766f6ad46f5d"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>Iterator_Matrix_Sparse_Row&lt; const matrix &gt;</b></td></tr>
<tr class="separator:a95f0ba020da860e1f378766f6ad46f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0460d096615183dab76c16a1529cdaff"><td class="memItemLeft" align="right" valign="top"><a id="a0460d096615183dab76c16a1529cdaff" name="a0460d096615183dab76c16a1529cdaff"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>Iterator_Matrix_Sparse_Element&lt; matrix &gt;</b></td></tr>
<tr class="separator:a0460d096615183dab76c16a1529cdaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558a8a6d1c026d9ddafad0c8801fcd30"><td class="memItemLeft" align="right" valign="top"><a id="a558a8a6d1c026d9ddafad0c8801fcd30" name="a558a8a6d1c026d9ddafad0c8801fcd30"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>Iterator_Matrix_Sparse_Element&lt; const matrix &gt;</b></td></tr>
<tr class="separator:a558a8a6d1c026d9ddafad0c8801fcd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea918dac3cb471b0436a1712c37d3c15"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDisa_1_1Matrix__Sparse.html#aea918dac3cb471b0436a1712c37d3c15">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;<a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a>)</td></tr>
<tr class="memdesc:aea918dac3cb471b0436a1712c37d3c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output shift operator - to write to console.  <a href="classDisa_1_1Matrix__Sparse.html#aea918dac3cb471b0436a1712c37d3c15">More...</a><br /></td></tr>
<tr class="separator:aea918dac3cb471b0436a1712c37d3c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A efficient data structure which represents a matrix comprised of mostly zero entries. Follows compact storage row (CSR) approach. </p>
<p >The <a class="el" href="classDisa_1_1Matrix__Sparse.html" title="A efficient data structure which represents a matrix comprised of mostly zero entries....">Matrix_Sparse</a> struct implements a mathematical matrix of nxm real numbers, but only stores memory for non-zero entries.</p>
<p >A CSR matrix stores three vectors; the first indicates the number of non-zeros per row (row_non_zero), this is achieved by recording, for each element (row) in the row_non_zero vector the accumulated non-zeros upto that row. With the last element being one greater than n, the number of rows, and recording the total number of non-zeros in the matrix. The next vector stores the column indexes (column_index) for each non-zero matrix element, and for each row the indexes are sorted in an ascending manner. The start of each row's columns in the column index vector is given by the value in row_non_zero for that row. Finally, the last vector contains the values of each non-zero element (element_value) and has a one-to-one correspondence with column_index vector. The last piece of data stored is the number of columns in the matrix, this ensures correctness of mathematical operations.</p>
<p >From a design perspective the class has two goals. The first is for the class to have a behaviour similar to that of a dense matrix for sub-script operators and class iterators. This is achieved via a helper class and two iterator classes which allow (range) loops over rows and then columns, further non-const subscript operators are fully able to add non-zero entries to the matrix (just be aware this may invalidate iterators). Finally, the use of iterators (when) accessed sequentially allows for efficient caching, the use of the element_iterator::i_row() and element_iterator::i_column() functions also allow for the iterator to provide use for information about the dereferenceable matrix entry.</p>
<p >The second goal is to have have the class have a behaviour similar to a std::map structure, where the 'key' is the row-column index pair for an entry. Thus functions, not normally associated with continuous structures (eg find, contains, lower_bound, etc), are supported by the matrix.</p>
<dl class="section note"><dt>Note</dt><dd>The user should be aware of the following:<ol type="1">
<li>Iterators advance over non-zero data - i.e. an iterator will not be dereferenceable to a zero entry (when defined behaviour is expected).</li>
<li>Unlike map or vector erasure functions do not effect the size of the matrix only the number of non-zeroes.</li>
</ol>
<ol type="1">
<li>Unlike map or vector insertion functions, size is only changed if the row or column index exceeds the matrix row or column size respectively, the number of non-zeroes will however always change.</li>
<li>Non-const sub-script operators behave like a map in terms of overflow, i.e. the matrix is resized to accommodate entries added past the last row or column.</li>
<li>As with all '<a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> iterators', dereferencing should be considered undefined behaviour, with particular focus on a row <a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> iterator, which may dereference to the first entry on the next row (you have been warned).</li>
</ol>
</dd></dl>
<p>Future:</p><ol type="1">
<li>If further sparse matrices are added to Disa then this class should be renamed to Matrix_Sparse_CSR </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa382150da0d7ea1b72bc06ed219215a3" name="aa382150da0d7ea1b72bc06ed219215a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa382150da0d7ea1b72bc06ed219215a3">&#9670;&#160;</a></span>Matrix_Sparse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Disa::Matrix_Sparse::Matrix_Sparse </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sparse matrix with a set number of rows and columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>Number of rows to construct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column</td><td>Number of columns to construct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cff83464b43fe9569f140e9a1130d6b" name="a0cff83464b43fe9569f140e9a1130d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cff83464b43fe9569f140e9a1130d6b">&#9670;&#160;</a></span>Matrix_Sparse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Disa::Matrix_Sparse::Matrix_Sparse </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>non_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; Scalar &gt;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer list based on the 'raw' data structure of a sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">non_zero</td><td>The non-zero offsets per row, must be sized to number of rows + 1, and the first index should be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The column index of the non-zero value in each row, size must correspond to value, need not be be sorted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value at each non-zero position in the matrix, corresponds to index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column</td><td>The absolute number of columns per row.</td></tr>
  </table>
  </dd>
</dl>
<p>A number of checks are performed to ensure that the parsed initializer lists are consistent. The checks include:</p>
<ol type="1">
<li>The first value in the non-zero offset vector is 0.</li>
<li>Making sure the number of non-zeros matches the last offset value in the parsed non-zero vector.</li>
<li>The non-zero offsets or sorted in an ascending manner.</li>
<li>The column index size matches the value size.</li>
<li>For each row of column indexes the indexes are unique and within the parsed column size. </li>
</ol>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a91b8307cbd125de4afe193208a9168b0" name="a91b8307cbd125de4afe193208a9168b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b8307cbd125de4afe193208a9168b0">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double &amp; Disa::Matrix_Sparse::at </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access specified element with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_row</td><td>The row index of the element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_column</td><td>The column index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the element.</dd></dl>
<p>Using lower bound, finds and returns the element value at the requested row and column index. If it does not exist an error is thrown. </p>

</div>
</div>
<a id="a8d0a1744629534509e385c1e0edc1135" name="a8d0a1744629534509e385c1e0edc1135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0a1744629534509e385c1e0edc1135">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double &amp; Disa::Matrix_Sparse::at </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access specified element with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_row</td><td>The row index of the element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_column</td><td>The column index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the element.</dd></dl>
<p>Using lower bound, finds and returns the element value, as a const, at the requested row and column index. If it does not exist an error is thrown. </p>

</div>
</div>
<a id="ac469863648160c38e3c56e7d81a7ae0e" name="ac469863648160c38e3c56e7d81a7ae0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac469863648160c38e3c56e7d81a7ae0e">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">Matrix_Sparse::const_iterator</a> Disa::Matrix_Sparse::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the beginning row of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant row iterator.</dd></dl>
<p>Constructs and returns a constant sparse matrix row iterator for the first row. </p>

</div>
</div>
<a id="acbbfaa8f2d019ac0cdc544209da88dea" name="acbbfaa8f2d019ac0cdc544209da88dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbfaa8f2d019ac0cdc544209da88dea">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">Matrix_Sparse::iterator</a> Disa::Matrix_Sparse::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning row of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>A row iterator.</dd></dl>
<p>Constructs and returns a sparse matrix row iterator for the first row. </p>

</div>
</div>
<a id="a7cf098c5c8afd5683405c9c3dd05b664" name="a7cf098c5c8afd5683405c9c3dd05b664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf098c5c8afd5683405c9c3dd05b664">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::size_t, std::size_t &gt; Disa::Matrix_Sparse::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of row offsets and non-zeros entries that can be held in currently allocated storage. </p>
<dl class="section return"><dt>Returns</dt><dd>[number of rows offsets, number of non-zeros entries.]</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The number of row offsets (for CSR matrices) is always one greater than the actual matrix row size. </dd></dl>

</div>
</div>
<a id="ae46849cea10ff98c6bc40713ae4fbb58" name="ae46849cea10ff98c6bc40713ae4fbb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46849cea10ff98c6bc40713ae4fbb58">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">Matrix_Sparse::const_iterator</a> Disa::Matrix_Sparse::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the beginning row of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant row iterator.</dd></dl>
<p>Constructs and returns a constant sparse matrix row iterator for the first row. </p>

</div>
</div>
<a id="aab8a3f9795d9dab326cd45755c8fda09" name="aab8a3f9795d9dab326cd45755c8fda09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8a3f9795d9dab326cd45755c8fda09">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">Matrix_Sparse::const_iterator</a> Disa::Matrix_Sparse::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the end row (i.e. 1 past the last row) of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>A row iterator.</dd></dl>
<p>Constructs and returns a constant sparse matrix row iterator for 'a row' past the last row. </p>

</div>
</div>
<a id="aca5937c136cd9f470c56dc431e7d1e21" name="aca5937c136cd9f470c56dc431e7d1e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5937c136cd9f470c56dc431e7d1e21">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Disa::Matrix_Sparse::contains </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the element at a row and column are non-zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_row</td><td>The row index to the element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_column</td><td>The column index to the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if non-zero, else false.</dd></dl>
<p>Calls find, if the iterator is referencable true is returned, else false. </p>

</div>
</div>
<a id="a191b6c57c900c92e9eeeb06dd959704d" name="a191b6c57c900c92e9eeeb06dd959704d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191b6c57c900c92e9eeeb06dd959704d">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::size_t *, std::size_t *, Scalar * &gt; Disa::Matrix_Sparse::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classDisa_1_1Direct.html" title="Direct Dense Linear Solver Base Class.">Direct</a> access to the underlying array of the sparse matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>tuple [pointer to non zero offset start, pointer to column index start, pointer to Scalar start].</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If empty all pointers will be nullptrs, if the size_non_zero is 0 the element and column index will be nullptrs.</dd></dl>
<p>todo: Add test for function. </p>

</div>
</div>
<a id="a707bc4a0afb01e76a9afa98226d6c1f9" name="a707bc4a0afb01e76a9afa98226d6c1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707bc4a0afb01e76a9afa98226d6c1f9">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Disa::Matrix_Sparse::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the matrix is empty. An empty matrix is considered where the number of rows is 0. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the matrix is empty, else false. </dd></dl>

</div>
</div>
<a id="aca05793b24448cf4e9552eade5ab477c" name="aca05793b24448cf4e9552eade5ab477c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca05793b24448cf4e9552eade5ab477c">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">Matrix_Sparse::const_iterator</a> Disa::Matrix_Sparse::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the end row (i.e. 1 past the last row) of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>A row iterator.</dd></dl>
<p>Constructs and returns a constant sparse matrix row iterator for 'a row' past the last row. </p>

</div>
</div>
<a id="a1c17a55f0b505c9e8a84898b98d6c9df" name="a1c17a55f0b505c9e8a84898b98d6c9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c17a55f0b505c9e8a84898b98d6c9df">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Row.html">Matrix_Sparse::iterator</a> Disa::Matrix_Sparse::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end row (i.e. 1 past the last row) of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>A row iterator.</dd></dl>
<p>Constructs and returns a sparse matrix row iterator for 'a row' past the last row. </p>

</div>
</div>
<a id="a6679eaabb10d4be6a5e0d85ebcc9b97e" name="a6679eaabb10d4be6a5e0d85ebcc9b97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6679eaabb10d4be6a5e0d85ebcc9b97e">&#9670;&#160;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">Matrix_Sparse::iterator_element</a> Disa::Matrix_Sparse::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">Iterator_Matrix_Sparse_Element</a>&lt; <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>iter_element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases a value at the specified row and column, using an element iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter_element</td><td>The iterator to the value to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator to the value after the deleted value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Undefined behaviour exists if the element does not exist, i.e. the iterator must be dereferenceable.</dd></dl>
<p>Erases a element from the matrix, if the element does not exist and error is thrown in debug. The number of row non-zeros at the row is decremented for the 'next row' and propagated to the rest of the row non-zero vector. The value and column index vectors have the associated matrix entry data erased (reducing their size by 1). </p>

</div>
</div>
<a id="ac8ad3d410781a3f505a4d2cf0dcb997e" name="ac8ad3d410781a3f505a4d2cf0dcb997e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ad3d410781a3f505a4d2cf0dcb997e">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">Matrix_Sparse::iterator_element</a> Disa::Matrix_Sparse::find </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the value iterator to the matrix value at a row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_row</td><td>The row index to the element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_column</td><td>The column index to the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element iterator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If i_row &gt;= row_size() <a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> is returned, if no element is found *(begin + i_row).<a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> is returned.</dd></dl>
<p>If the parsed row is in range, the column index is searched using std::find in the given sparse matrix row. An iterator to the found matrix entry is constructed and returned. If the entry is not contained in the sparse matrix, an <a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> or *(begin + i_row).<a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> iterator is constructed. </p>

</div>
</div>
<a id="ae893703db2a63335c1f43c3be08bc687" name="ae893703db2a63335c1f43c3be08bc687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae893703db2a63335c1f43c3be08bc687">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">Matrix_Sparse::const_iterator_element</a> Disa::Matrix_Sparse::find </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the value iterator to the matrix value at a row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_row</td><td>The row index to the element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_column</td><td>The column index to the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constant element iterator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If i_row &gt;= row_size() <a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> is returned, if no element is found *(begin + i_row).<a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> is returned.</dd></dl>
<p>If the parsed row is in range, the column index is searched using std::find in the given sparse matrix row. A const iterator to the found matrix entry is constructed and returned. If the entry is not contained in the sparse matrix, an <a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> or *(begin + i_row).<a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> iterator is constructed. </p>

</div>
</div>
<a id="a1db3c11fd4d31fd9b3f7754f3954bccd" name="a1db3c11fd4d31fd9b3f7754f3954bccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db3c11fd4d31fd9b3f7754f3954bccd">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">Matrix_Sparse::iterator_element</a>, bool &gt; Disa::Matrix_Sparse::insert </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an value with the parsed value at [i_row, i_column], if an value exists nothing occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_row</td><td>The i_row index to the insert value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_column</td><td>The i_column index to the insert value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[iterator to the inserted or existing element, true if insertion took place, else false].</dd></dl>
<p>If the value to be inserted has a row or column index greater than the current size of the matrix, the matrix is resized to accommodate the insertion. Lower bound is then used to find the iterator to the position where the new value is to be inserted. If there is a value already present at the position the function 'aborts' reporting this as false in the second value of the pair. Otherwise the row non-zero vector us updated indicating the new non-zero in the row by propagating the offset incrementation to the remaining parts of the vector. The column index and element value vectors are appropriately updated. </p>

</div>
</div>
<a id="a3f048f42cc4229c9ceb47d42557aa185" name="a3f048f42cc4229c9ceb47d42557aa185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f048f42cc4229c9ceb47d42557aa185">&#9670;&#160;</a></span>insert_or_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">Matrix_Sparse::iterator_element</a>, bool &gt; Disa::Matrix_Sparse::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts or updates an value with the parsed value at [i_row, i_column]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_row</td><td>The i_row index to the insert value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_column</td><td>The i_column index to the insert value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[iterator to the inserted or existing element, true if insertion took place, else false].</dd></dl>
<p>First the function will attempt to insert with the parsed value. If this fails the value will be assigned to the existing matrix element. </p>

</div>
</div>
<a id="ac457fb034cdd0ca3b1f732cd76354ead" name="ac457fb034cdd0ca3b1f732cd76354ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac457fb034cdd0ca3b1f732cd76354ead">&#9670;&#160;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">Matrix_Sparse::iterator_element</a> Disa::Matrix_Sparse::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an element iterator to the first element not less than the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_row</td><td>The row index to the element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_column</td><td>The column index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is not less than key.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If i_row &gt;= row_size() <a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> is returned, if no element is found *(begin + i_row).<a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> is returned.</dd></dl>
<p>If the parsed row is in range, the column index is searched using std::lower_bound in the given sparse matrix row. An iterator is then constructed from the first column index not less than the parsed column index. If the row is greater than the number of rows an <a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> iterator is constructed. </p>

</div>
</div>
<a id="af77685121fab9302dd42f0f0ad6c4e63" name="af77685121fab9302dd42f0f0ad6c4e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77685121fab9302dd42f0f0ad6c4e63">&#9670;&#160;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDisa_1_1Iterator__Matrix__Sparse__Element.html">Matrix_Sparse::const_iterator_element</a> Disa::Matrix_Sparse::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an element iterator to the first element not less than the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_row</td><td>The row index to the element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_column</td><td>The column index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator pointing to the first element that is not less than key.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If i_row &gt;= row_size() <a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> is returned, if no element is found *(begin + i_row).<a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> is returned.</dd></dl>
<p>If the parsed row is in range, the column index is searched using std::lower_bound in the given sparse matrix row. A const iterator is then constructed from the first column index not less than the parsed column index. If the row is greater than the number of rows an <a class="el" href="classDisa_1_1Matrix__Sparse.html#a1c17a55f0b505c9e8a84898b98d6c9df" title="Returns an iterator to the end row (i.e. 1 past the last row) of the matrix.">end()</a> iterator is constructed. </p>

</div>
</div>
<a id="a124ba6fbcc1ca4f174fd6bef91bd3dd3" name="a124ba6fbcc1ca4f174fd6bef91bd3dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124ba6fbcc1ca4f174fd6bef91bd3dd3">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDisa_1_1Matrix__Sparse.html">Matrix_Sparse</a> &amp; Disa::Matrix_Sparse::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this matrix by another, A' = A*B, where A and B are matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The second other, B, to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated matrix (A').</dd></dl>
<p>A very basic SpGEMM algorithm, a simple loop through the rows and columns of each matrix looking for non-zero entries to multiply and construct and return the resulting matrix. In debug the matrix sizes are checked for compatibility. </p>

</div>
</div>
<a id="a93839da27fad6a1162e34a6c72ec2af3" name="a93839da27fad6a1162e34a6c72ec2af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93839da27fad6a1162e34a6c72ec2af3">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp; Disa::Matrix_Sparse::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the matrix by a scalar, A' = A*b, where A is the matrix and b is the scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>Scalar value, b, to multiply the matrix by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated matrix (A'). </dd></dl>

</div>
</div>
<a id="a4d8dc7d58ae426db3564805963be34f6" name="a4d8dc7d58ae426db3564805963be34f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8dc7d58ae426db3564805963be34f6">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp; Disa::Matrix_Sparse::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition of a second matrix, A' = A + B, where A and B are matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The second matrix, B, to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated matrix (A'). </dd></dl>

</div>
</div>
<a id="a3f43906d741a4e699cefd53421f1d19e" name="a3f43906d741a4e699cefd53421f1d19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f43906d741a4e699cefd53421f1d19e">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp; Disa::Matrix_Sparse::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction by a second matrix, A' = A - B, where A and B are matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The second matrix, B, to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated matrix (A'). </dd></dl>

</div>
</div>
<a id="a43ff1630e174662e2ad1c59aa303cc90" name="a43ff1630e174662e2ad1c59aa303cc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ff1630e174662e2ad1c59aa303cc90">&#9670;&#160;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp; Disa::Matrix_Sparse::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides the matrix by a scalar, A' = A/b, where A is the matrix and b is a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>Scalar value, b, to multiply the vector by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated matrix (A').</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Division by zero is left to the user to handle. </dd></dl>

</div>
</div>
<a id="ae5e9352bab07ef7ed4780f2c1041bf59" name="ae5e9352bab07ef7ed4780f2c1041bf59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e9352bab07ef7ed4780f2c1041bf59">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp; Disa::Matrix_Sparse::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a trivial deep copy of the assigned matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other sparse matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated copy of this matrix. </dd></dl>

</div>
</div>
<a id="a4dd6f303a93389d16e069cf7c1493952" name="a4dd6f303a93389d16e069cf7c1493952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd6f303a93389d16e069cf7c1493952">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDisa_1_1Matrix__Sparse__Row.html">Matrix_Sparse_Row</a>&lt; <a class="el" href="classDisa_1_1Matrix__Sparse.html">Matrix_Sparse</a> &gt; Disa::Matrix_Sparse::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscript operator for access to a specified matrix row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_row</td><td>The row index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sparse matrix row helper class, providing further operators for column access.</dd></dl>
<p>Constructs and returns a sparse matrix row object for the given row. In debug range checking is performed. </p>

</div>
</div>
<a id="acf2c0e3d3e20e46f5230f7485ff37d82" name="acf2c0e3d3e20e46f5230f7485ff37d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2c0e3d3e20e46f5230f7485ff37d82">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDisa_1_1Matrix__Sparse__Row.html">Matrix_Sparse_Row</a>&lt; const <a class="el" href="classDisa_1_1Matrix__Sparse.html">Matrix_Sparse</a> &gt; Disa::Matrix_Sparse::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscript operator for access to a specified matrix row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_row</td><td>The row index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant sparse matrix row helper class, providing further operators for column access.</dd></dl>
<p>Constructs and returns a sparse matrix row object for the given row. In debug range checking is performed. </p>

</div>
</div>
<a id="abb2ca51fadda30ae1963f861d2aaa3b4" name="abb2ca51fadda30ae1963f861d2aaa3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2ca51fadda30ae1963f861d2aaa3b4">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Disa::Matrix_Sparse::reserve </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>non_zero</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves storage for the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>The number of rows to reserve for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">non_zero</td><td>The number of non-zeros to reserve. Note this is not the column size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The number of row offsets which are reserved will be one greater than the row size passed. </dd></dl>

</div>
</div>
<a id="a8cbed30634d3e1b28566c2581af03896" name="a8cbed30634d3e1b28566c2581af03896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbed30634d3e1b28566c2581af03896">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Disa::Matrix_Sparse::resize </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the number of rows and columns of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>Number of rows to resized the matrix to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column</td><td>Number of columns to resized the matrix to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does not effect number of non-zeros, unless the new row and column sizes reduce the size of the matrix.</dd></dl>
<p>For general increase in size the row non-zero vector is resized, with the new entries containing the current row non-zero back() value. For column size increase the column_size member is updated. If the rows are to be reduced, however, all the column indexes and element values greater than the row non-zero value at the new row size are erased. Finally, a column reduction requires looping over all rows to determine which column indexes and element values have 'fallen away'. These entries are removed from the vector and the total update of non-zeros is then propagated through the remainder of the row non-zero vector (in an efficient way). </p>

</div>
</div>
<a id="a6bc017a21bb48701c6d7fd3fd1e74d76" name="a6bc017a21bb48701c6d7fd3fd1e74d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc017a21bb48701c6d7fd3fd1e74d76">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::size_t, std::size_t &gt; Disa::Matrix_Sparse::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of rows and columns in the matrix. If rows are 0, columns are 0. </p>
<dl class="section return"><dt>Returns</dt><dd>Pair containing [rows, columns]. </dd></dl>

</div>
</div>
<a id="aed3a2fd59ab0ffc8b2911ebf4465e377" name="aed3a2fd59ab0ffc8b2911ebf4465e377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3a2fd59ab0ffc8b2911ebf4465e377">&#9670;&#160;</a></span>size_column()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Disa::Matrix_Sparse::size_column </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of columns. </dd></dl>

</div>
</div>
<a id="a23f3cba86a8796d8996b2d401410550e" name="a23f3cba86a8796d8996b2d401410550e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f3cba86a8796d8996b2d401410550e">&#9670;&#160;</a></span>size_non_zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Disa::Matrix_Sparse::size_non_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zeros in the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zeros. </dd></dl>

</div>
</div>
<a id="a2e20cba0ddb4dcde4d02058168b50cdc" name="a2e20cba0ddb4dcde4d02058168b50cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e20cba0ddb4dcde4d02058168b50cdc">&#9670;&#160;</a></span>size_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Disa::Matrix_Sparse::size_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of rows in the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of rows. </dd></dl>

</div>
</div>
<a id="a9167eef9bae2398d3857db8b68b79dfb" name="a9167eef9bae2398d3857db8b68b79dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9167eef9bae2398d3857db8b68b79dfb">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Disa::Matrix_Sparse::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the matrix with the parsed matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The other matrix, this matrix will obtain the other's value and visa versa. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aea918dac3cb471b0436a1712c37d3c15" name="aea918dac3cb471b0436a1712c37d3c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea918dac3cb471b0436a1712c37d3c15">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDisa_1_1Matrix__Sparse.html">matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output shift operator - to write to console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stream</td><td>Stream object to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The sparse matrix to write out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inputted stream.</dd></dl>
<p>todo: properly format - this is just here to help occasional debugging. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libs/core/<a class="el" href="matrix__sparse_8h_source.html">matrix_sparse.h</a></li>
<li>libs/core/matrix_sparse.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
