<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Disa: Adjacency_Subgraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Disa
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_disa_1_1_adjacency___subgraph.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Adjacency_Subgraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="adjacency__subgraph_8h_source.html">adjacency_subgraph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af246354bc15091bc83bf59495a3ca2e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#af246354bc15091bc83bf59495a3ca2e1">Adjacency_Subgraph</a> ()=default</td></tr>
<tr class="memdesc:af246354bc15091bc83bf59495a3ca2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_disa_1_1_adjacency___subgraph.html#af246354bc15091bc83bf59495a3ca2e1">More...</a><br /></td></tr>
<tr class="separator:af246354bc15091bc83bf59495a3ca2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb8041b5ac201610be65864fbce4da5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a0eb8041b5ac201610be65864fbce4da5">~Adjacency_Subgraph</a> ()=default</td></tr>
<tr class="memdesc:a0eb8041b5ac201610be65864fbce4da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="class_disa_1_1_adjacency___subgraph.html#a0eb8041b5ac201610be65864fbce4da5">More...</a><br /></td></tr>
<tr class="separator:a0eb8041b5ac201610be65864fbce4da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d125c03c34d17ff12018825d171deae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a2d125c03c34d17ff12018825d171deae">Adjacency_Subgraph</a> (const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a> &amp;parent_graph, const std::vector&lt; std::size_t &gt; &amp;i_sub_graph_vertex, std::size_t extra_levels=0)</td></tr>
<tr class="memdesc:a2d125c03c34d17ff12018825d171deae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for creating a subgraph from a parent graph.  <a href="class_disa_1_1_adjacency___subgraph.html#a2d125c03c34d17ff12018825d171deae">More...</a><br /></td></tr>
<tr class="separator:a2d125c03c34d17ff12018825d171deae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef9de02b4c8ec387321aaa3eefe6a30"><td class="memItemLeft" align="right" valign="top">std::span&lt; const size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a2ef9de02b4c8ec387321aaa3eefe6a30">at</a> (const std::size_t &amp;i_vertex) const</td></tr>
<tr class="memdesc:a2ef9de02b4c8ec387321aaa3eefe6a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for access to a specified graph vertex's adjacency, with range checking.  <a href="class_disa_1_1_adjacency___subgraph.html#a2ef9de02b4c8ec387321aaa3eefe6a30">More...</a><br /></td></tr>
<tr class="separator:a2ef9de02b4c8ec387321aaa3eefe6a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffd3889c5d38a1a8ab86abcadc98070"><td class="memItemLeft" align="right" valign="top">std::span&lt; const std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#afffd3889c5d38a1a8ab86abcadc98070">operator[]</a> (const std::size_t &amp;i_vertex) const</td></tr>
<tr class="memdesc:afffd3889c5d38a1a8ab86abcadc98070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for access to a specified graph vertex's adjacency.  <a href="class_disa_1_1_adjacency___subgraph.html#afffd3889c5d38a1a8ab86abcadc98070">More...</a><br /></td></tr>
<tr class="separator:afffd3889c5d38a1a8ab86abcadc98070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bda48d930c6060c12bb296148ed46c"><td class="memItemLeft" align="right" valign="top">std::span&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#ad7bda48d930c6060c12bb296148ed46c">operator[]</a> (const std::size_t &amp;i_vertex)</td></tr>
<tr class="memdesc:ad7bda48d930c6060c12bb296148ed46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for access to a specified graph vertex's adjacency.  <a href="class_disa_1_1_adjacency___subgraph.html#ad7bda48d930c6060c12bb296148ed46c">More...</a><br /></td></tr>
<tr class="separator:ad7bda48d930c6060c12bb296148ed46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5c1633e9bffac331b9ac49e51fddd9"><td class="memItemLeft" align="right" valign="top">std::span&lt; const std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a4e5c1633e9bffac331b9ac49e51fddd9">front</a> () const</td></tr>
<tr class="memdesc:a4e5c1633e9bffac331b9ac49e51fddd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first vertex's adjacency.  <a href="class_disa_1_1_adjacency___subgraph.html#a4e5c1633e9bffac331b9ac49e51fddd9">More...</a><br /></td></tr>
<tr class="separator:a4e5c1633e9bffac331b9ac49e51fddd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e607af4c860098f9ca9ac314c6c38c"><td class="memItemLeft" align="right" valign="top">std::span&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a19e607af4c860098f9ca9ac314c6c38c">front</a> ()</td></tr>
<tr class="memdesc:a19e607af4c860098f9ca9ac314c6c38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first vertex's adjacency.  <a href="class_disa_1_1_adjacency___subgraph.html#a19e607af4c860098f9ca9ac314c6c38c">More...</a><br /></td></tr>
<tr class="separator:a19e607af4c860098f9ca9ac314c6c38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd668ce0bc9f0c652923b9fbc10241d"><td class="memItemLeft" align="right" valign="top">std::span&lt; const std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#affd668ce0bc9f0c652923b9fbc10241d">back</a> () const</td></tr>
<tr class="memdesc:affd668ce0bc9f0c652923b9fbc10241d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last vertex's adjacency.  <a href="class_disa_1_1_adjacency___subgraph.html#affd668ce0bc9f0c652923b9fbc10241d">More...</a><br /></td></tr>
<tr class="separator:affd668ce0bc9f0c652923b9fbc10241d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c9139690af084bde55f3188900a8e9"><td class="memItemLeft" align="right" valign="top">std::span&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#ae7c9139690af084bde55f3188900a8e9">back</a> ()</td></tr>
<tr class="memdesc:ae7c9139690af084bde55f3188900a8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last vertex's adjacency.  <a href="class_disa_1_1_adjacency___subgraph.html#ae7c9139690af084bde55f3188900a8e9">More...</a><br /></td></tr>
<tr class="separator:ae7c9139690af084bde55f3188900a8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac404ec58dda9419845a75590d66d08c0"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::size_t *, std::size_t *, std::size_t *, std::size_t * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#ac404ec58dda9419845a75590d66d08c0">data</a> () noexcept</td></tr>
<tr class="memdesc:ac404ec58dda9419845a75590d66d08c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_disa_1_1_direct.html" title="Direct Dense Linear Solver Base Class.">Direct</a> access to the underlying vectors of the graph.  <a href="class_disa_1_1_adjacency___subgraph.html#ac404ec58dda9419845a75590d66d08c0">More...</a><br /></td></tr>
<tr class="separator:ac404ec58dda9419845a75590d66d08c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6fc5de06a318920d84f3c3742db07f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a3f6fc5de06a318920d84f3c3742db07f">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a3f6fc5de06a318920d84f3c3742db07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the graph is empty.  <a href="class_disa_1_1_adjacency___subgraph.html#a3f6fc5de06a318920d84f3c3742db07f">More...</a><br /></td></tr>
<tr class="separator:a3f6fc5de06a318920d84f3c3742db07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6278cc8407882022d4790eadf867860c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a6278cc8407882022d4790eadf867860c">size_vertex</a> () const noexcept</td></tr>
<tr class="memdesc:a6278cc8407882022d4790eadf867860c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices in the graph.  <a href="class_disa_1_1_adjacency___subgraph.html#a6278cc8407882022d4790eadf867860c">More...</a><br /></td></tr>
<tr class="separator:a6278cc8407882022d4790eadf867860c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13038ad8e3b198ec30c83e3ac524f2f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#ae13038ad8e3b198ec30c83e3ac524f2f">size_edge</a> () const noexcept</td></tr>
<tr class="memdesc:ae13038ad8e3b198ec30c83e3ac524f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edge in the graph.  <a href="class_disa_1_1_adjacency___subgraph.html#ae13038ad8e3b198ec30c83e3ac524f2f">More...</a><br /></td></tr>
<tr class="separator:ae13038ad8e3b198ec30c83e3ac524f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499b30f71b7401e327ecd9faa0ab676c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a499b30f71b7401e327ecd9faa0ab676c">size</a> () const noexcept</td></tr>
<tr class="memdesc:a499b30f71b7401e327ecd9faa0ab676c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices and edges in the graph.  <a href="class_disa_1_1_adjacency___subgraph.html#a499b30f71b7401e327ecd9faa0ab676c">More...</a><br /></td></tr>
<tr class="separator:a499b30f71b7401e327ecd9faa0ab676c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaee28b4b5bc819b62e8a676b85f17a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#acaee28b4b5bc819b62e8a676b85f17a1">reserve</a> (std::size_t <a class="el" href="class_disa_1_1_adjacency___subgraph.html#a6278cc8407882022d4790eadf867860c">size_vertex</a>, std::size_t <a class="el" href="class_disa_1_1_adjacency___subgraph.html#ae13038ad8e3b198ec30c83e3ac524f2f">size_edge</a>=0) noexcept</td></tr>
<tr class="memdesc:acaee28b4b5bc819b62e8a676b85f17a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves enough memory such that the data structure can be filled with the parsed vertices and/or edges.  <a href="class_disa_1_1_adjacency___subgraph.html#acaee28b4b5bc819b62e8a676b85f17a1">More...</a><br /></td></tr>
<tr class="separator:acaee28b4b5bc819b62e8a676b85f17a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f5a82d885154b06a9fa0096e41ea06"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, std::size_t, std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a78f5a82d885154b06a9fa0096e41ea06">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a78f5a82d885154b06a9fa0096e41ea06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of vertices and edges the graph has capacity (memory for).  <a href="class_disa_1_1_adjacency___subgraph.html#a78f5a82d885154b06a9fa0096e41ea06">More...</a><br /></td></tr>
<tr class="separator:a78f5a82d885154b06a9fa0096e41ea06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e4af5032d71179d3abf04db463f791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#ad9e4af5032d71179d3abf04db463f791">shrink_to_fit</a> () noexcept</td></tr>
<tr class="memdesc:ad9e4af5032d71179d3abf04db463f791"><td class="mdescLeft">&#160;</td><td class="mdescRight">reduces memory usage of the graph by freeing unused memory for both vertices and edges.  <a href="class_disa_1_1_adjacency___subgraph.html#ad9e4af5032d71179d3abf04db463f791">More...</a><br /></td></tr>
<tr class="separator:ad9e4af5032d71179d3abf04db463f791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr class="memdesc:ac8bb3912a3ce86b15842e79d0b421204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the contents of the graph, removing all vertices and edges.  <a href="class_disa_1_1_adjacency___subgraph.html#ac8bb3912a3ce86b15842e79d0b421204">More...</a><br /></td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac470d793633cd0a95d58589b561d8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a4ac470d793633cd0a95d58589b561d8d">resize</a> (const std::size_t <a class="el" href="class_disa_1_1_adjacency___subgraph.html#a499b30f71b7401e327ecd9faa0ab676c">size</a>)</td></tr>
<tr class="memdesc:a4ac470d793633cd0a95d58589b561d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the number of vertices in the graph.  <a href="class_disa_1_1_adjacency___subgraph.html#a4ac470d793633cd0a95d58589b561d8d">More...</a><br /></td></tr>
<tr class="separator:a4ac470d793633cd0a95d58589b561d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4a6ced26dca3a8d702c4dedd486a41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a2e4a6ced26dca3a8d702c4dedd486a41">swap</a> (<a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a> &amp;graph_other)</td></tr>
<tr class="memdesc:a2e4a6ced26dca3a8d702c4dedd486a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the graph with the parsed graph.  <a href="class_disa_1_1_adjacency___subgraph.html#a2e4a6ced26dca3a8d702c4dedd486a41">More...</a><br /></td></tr>
<tr class="separator:a2e4a6ced26dca3a8d702c4dedd486a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1995f33622008acb17fc118451503bdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a1995f33622008acb17fc118451503bdb">contains</a> (const <a class="el" href="namespace_disa.html#a5d0458dbd92d3cbd94eddeb318b6d88f">Edge</a> &amp;edge) const</td></tr>
<tr class="memdesc:a1995f33622008acb17fc118451503bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the edge exists in the graph.  <a href="class_disa_1_1_adjacency___subgraph.html#a1995f33622008acb17fc118451503bdb">More...</a><br /></td></tr>
<tr class="separator:a1995f33622008acb17fc118451503bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdb4c97aeb4ab71d8b2929fb9399090"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a7fdb4c97aeb4ab71d8b2929fb9399090">degree</a> (const std::size_t &amp;i_vertex) const</td></tr>
<tr class="memdesc:a7fdb4c97aeb4ab71d8b2929fb9399090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the degree of a vertex: defined as the number of vertices it adjacent (connected) to.  <a href="class_disa_1_1_adjacency___subgraph.html#a7fdb4c97aeb4ab71d8b2929fb9399090">More...</a><br /></td></tr>
<tr class="separator:a7fdb4c97aeb4ab71d8b2929fb9399090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ce524d1e4bd721d28d6d8903d91382"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#af7ce524d1e4bd721d28d6d8903d91382">is_local</a> (const std::size_t &amp;i_vertex) const</td></tr>
<tr class="memdesc:af7ce524d1e4bd721d28d6d8903d91382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the vertex local to this subgraph.  <a href="class_disa_1_1_adjacency___subgraph.html#af7ce524d1e4bd721d28d6d8903d91382">More...</a><br /></td></tr>
<tr class="separator:af7ce524d1e4bd721d28d6d8903d91382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1a5d13aa8ecfb23105b54b92359ff1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a8e1a5d13aa8ecfb23105b54b92359ff1">is_parent</a> (const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a> &amp;graph_parent) const noexcept</td></tr>
<tr class="memdesc:a8e1a5d13aa8ecfb23105b54b92359ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the parsed graph is the parent of this sub-graph.  <a href="class_disa_1_1_adjacency___subgraph.html#a8e1a5d13aa8ecfb23105b54b92359ff1">More...</a><br /></td></tr>
<tr class="separator:a8e1a5d13aa8ecfb23105b54b92359ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfadd9095e0098019b0f28bfd1162b96"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#abfadd9095e0098019b0f28bfd1162b96">local_global</a> (const std::size_t &amp;i_vertex) const</td></tr>
<tr class="memdesc:abfadd9095e0098019b0f28bfd1162b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global index of a local vertex.  <a href="class_disa_1_1_adjacency___subgraph.html#abfadd9095e0098019b0f28bfd1162b96">More...</a><br /></td></tr>
<tr class="separator:abfadd9095e0098019b0f28bfd1162b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcf16cce1cc2fa5f4b7d96646e33221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a1fcf16cce1cc2fa5f4b7d96646e33221">reorder</a> (const std::vector&lt; std::size_t &gt; &amp;permutation)</td></tr>
<tr class="memdesc:a1fcf16cce1cc2fa5f4b7d96646e33221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders this graph given a new index numbering.  <a href="class_disa_1_1_adjacency___subgraph.html#a1fcf16cce1cc2fa5f4b7d96646e33221">More...</a><br /></td></tr>
<tr class="separator:a1fcf16cce1cc2fa5f4b7d96646e33221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0d325a5b24ec16077a4153a3c78a9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#a7d0d325a5b24ec16077a4153a3c78a9a">update_levels</a> (const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a> &amp;parent_graph, std::size_t max_level, std::shared_ptr&lt; std::vector&lt; std::size_t &gt; &gt; i_global_local=nullptr)</td></tr>
<tr class="memdesc:a7d0d325a5b24ec16077a4153a3c78a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the number of 'halo' levels/vertices around the primary sub-graph.  <a href="class_disa_1_1_adjacency___subgraph.html#a7d0d325a5b24ec16077a4153a3c78a9a">More...</a><br /></td></tr>
<tr class="separator:a7d0d325a5b24ec16077a4153a3c78a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74963d1838b37a9db0a64a3bfb2813a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disa_1_1_adjacency___subgraph.html#ae74963d1838b37a9db0a64a3bfb2813a">vertex_level</a> (const std::size_t &amp;i_vertex) const</td></tr>
<tr class="memdesc:ae74963d1838b37a9db0a64a3bfb2813a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the level of a given vertex in the graph.  <a href="class_disa_1_1_adjacency___subgraph.html#ae74963d1838b37a9db0a64a3bfb2813a">More...</a><br /></td></tr>
<tr class="separator:ae74963d1838b37a9db0a64a3bfb2813a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af246354bc15091bc83bf59495a3ca2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af246354bc15091bc83bf59495a3ca2e1">&#9670;&nbsp;</a></span>Adjacency_Subgraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="section return"><dt>Returns</dt><dd>An empty <a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a>. </dd></dl>

</div>
</div>
<a id="a0eb8041b5ac201610be65864fbce4da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb8041b5ac201610be65864fbce4da5">&#9670;&nbsp;</a></span>~Adjacency_Subgraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<a id="a2d125c03c34d17ff12018825d171deae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d125c03c34d17ff12018825d171deae">&#9670;&nbsp;</a></span>Adjacency_Subgraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>parent_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_partition_local_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>extra_levels</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for creating a subgraph from a parent graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent_graph</td><td>The parent graph upon which this subgraph will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_partition_local_global</td><td>For this partition of the parent graph, the local to global index mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extra_levels</td><td>Additional levels to add to the primary partition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constructed <a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>There are no guarantees placed on the resulting local partition ordering.</dd></dl>
<p>Constructs a new subgraph using the given vertex partitioning of the parent graph. The resulting subgraph will form the primary partition with these vertices. This presently is achieved by copying the parent graph to the internal graph representation, and forming the global-local mappings and deleting vertices not in the subgraph. Finally, should extra levels be requested they are added to the subgraph. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ef9de02b4c8ec387321aaa3eefe6a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef9de02b4c8ec387321aaa3eefe6a30">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt;const size_t&gt; at </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for access to a specified graph vertex's adjacency, with range checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_vertex</td><td>The vertex index to the adjacency graph being sought. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A span of a single vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="ae7c9139690af084bde55f3188900a8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c9139690af084bde55f3188900a8e9">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt;std::size_t&gt; back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last vertex's adjacency. </p>
<dl class="section return"><dt>Returns</dt><dd>A span of a the last vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="affd668ce0bc9f0c652923b9fbc10241d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd668ce0bc9f0c652923b9fbc10241d">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt;const std::size_t&gt; back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last vertex's adjacency. </p>
<dl class="section return"><dt>Returns</dt><dd>A span of a the last vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="a78f5a82d885154b06a9fa0096e41ea06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f5a82d885154b06a9fa0096e41ea06">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t, std::size_t, std::size_t, std::size_t&gt; capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of vertices and edges the graph has capacity (memory for). </p>
<dl class="section return"><dt>Returns</dt><dd>tuple containing capacities for [vertices, edges]. </dd></dl>

</div>
</div>
<a id="ac8bb3912a3ce86b15842e79d0b421204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bb3912a3ce86b15842e79d0b421204">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the contents of the graph, removing all vertices and edges. </p>

</div>
</div>
<a id="a1995f33622008acb17fc118451503bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1995f33622008acb17fc118451503bdb">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_disa.html#a5d0458dbd92d3cbd94eddeb318b6d88f">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the edge exists in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>The edge to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the graph contains the edge, else false. </dd></dl>

</div>
</div>
<a id="ac404ec58dda9419845a75590d66d08c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac404ec58dda9419845a75590d66d08c0">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t*, std::size_t*, std::size_t*, std::size_t*&gt; data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_disa_1_1_direct.html" title="Direct Dense Linear Solver Base Class.">Direct</a> access to the underlying vectors of the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>pair [pointer to vertex start, pointer to offset start, pointer to local to global, pointer to levels].</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If empty all pointers returned pointers will be nullptrs. If there the vertex list is empty then the only non-nullptr will be for the offset vector. Finally, a nullptr will be return if the subgraph does not contain additional levels. </dd></dl>

</div>
</div>
<a id="a7fdb4c97aeb4ab71d8b2929fb9399090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdb4c97aeb4ab71d8b2929fb9399090">&#9670;&nbsp;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t degree </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the degree of a vertex: defined as the number of vertices it adjacent (connected) to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_vertex</td><td>The vertex index for which to compute the degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The degree of the vertex. </dd></dl>

</div>
</div>
<a id="a3f6fc5de06a318920d84f3c3742db07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6fc5de06a318920d84f3c3742db07f">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the graph is empty. </p>
<p>An empty graph is considered where there are no vertices. </p><dl class="section return"><dt>Returns</dt><dd>True if the graph is empty, else false. </dd></dl>

</div>
</div>
<a id="a19e607af4c860098f9ca9ac314c6c38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e607af4c860098f9ca9ac314c6c38c">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt;std::size_t&gt; front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first vertex's adjacency. </p>
<dl class="section return"><dt>Returns</dt><dd>A span of a the first vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="a4e5c1633e9bffac331b9ac49e51fddd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5c1633e9bffac331b9ac49e51fddd9">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt;const std::size_t&gt; front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first vertex's adjacency. </p>
<dl class="section return"><dt>Returns</dt><dd>A const span of a the first vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="af7ce524d1e4bd721d28d6d8903d91382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ce524d1e4bd721d28d6d8903d91382">&#9670;&nbsp;</a></span>is_local()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_local </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the vertex local to this subgraph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_vertex</td><td>The vertex to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vertex is part of this subgraph, else false. </dd></dl>

</div>
</div>
<a id="a8e1a5d13aa8ecfb23105b54b92359ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1a5d13aa8ecfb23105b54b92359ff1">&#9670;&nbsp;</a></span>is_parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph_parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the parsed graph is the parent of this sub-graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph_parent</td><td>The parent graph to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the graph is the parent, else false. </dd></dl>

</div>
</div>
<a id="abfadd9095e0098019b0f28bfd1162b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfadd9095e0098019b0f28bfd1162b96">&#9670;&nbsp;</a></span>local_global()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t local_global </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the global index of a local vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_vertex</td><td>The local vertex index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The global vertex index. </dd></dl>

</div>
</div>
<a id="ad7bda48d930c6060c12bb296148ed46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bda48d930c6060c12bb296148ed46c">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt;std::size_t&gt; operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for access to a specified graph vertex's adjacency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_vertex</td><td>The vertex index to the adjacency graph being sought. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A span of a single vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="afffd3889c5d38a1a8ab86abcadc98070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffd3889c5d38a1a8ab86abcadc98070">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt;const std::size_t&gt; operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for access to a specified graph vertex's adjacency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_vertex</td><td>The vertex index to the adjacency graph being sought. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A span of a single vertex adjacency in the graph. </dd></dl>

</div>
</div>
<a id="a1fcf16cce1cc2fa5f4b7d96646e33221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcf16cce1cc2fa5f4b7d96646e33221">&#9670;&nbsp;</a></span>reorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a> reorder </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders this graph given a new index numbering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">permutation</td><td>The permutation vector, mapping new_index = permutation[old_index]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old, un-permuted, adjacency graph.</dd></dl>
<p>Creates a new subgraph instance that is a reordered version of the current instance. The new subgraph contains the same vertices and edges as the original, but with their local indexes permuted based on the given permutation vector. Finally the new instance and this instance are swapped, with the now old instance returned. </p>

</div>
</div>
<a id="acaee28b4b5bc819b62e8a676b85f17a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaee28b4b5bc819b62e8a676b85f17a1">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_edge</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves enough memory such that the data structure can be filled with the parsed vertices and/or edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size_vertex</td><td>The total number of vertices to reserve for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_edge</td><td>The total number of edge to reserve for (defaults to zero). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ac470d793633cd0a95d58589b561d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac470d793633cd0a95d58589b561d8d">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the number of vertices in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of vertices to resize the graph to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Edges are removed if the graph size is reduced. And the parent graph is cleared. </dd>
<dd>
Invalidates the parent hash if size is increased. </dd></dl>

</div>
</div>
<a id="ad9e4af5032d71179d3abf04db463f791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e4af5032d71179d3abf04db463f791">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reduces memory usage of the graph by freeing unused memory for both vertices and edges. </p>

</div>
</div>
<a id="a499b30f71b7401e327ecd9faa0ab676c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499b30f71b7401e327ecd9faa0ab676c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::size_t, std::size_t&gt; size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of vertices and edges in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>Pair containing [vertices, edges]. </dd></dl>

</div>
</div>
<a id="ae13038ad8e3b198ec30c83e3ac524f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13038ad8e3b198ec30c83e3ac524f2f">&#9670;&nbsp;</a></span>size_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t size_edge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of edge in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of edge. </dd></dl>

</div>
</div>
<a id="a6278cc8407882022d4790eadf867860c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6278cc8407882022d4790eadf867860c">&#9670;&nbsp;</a></span>size_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t size_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of vertices in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices. </dd></dl>

</div>
</div>
<a id="a2e4a6ced26dca3a8d702c4dedd486a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4a6ced26dca3a8d702c4dedd486a41">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the graph with the parsed graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">graph_other</td><td>The other graph, this graph will obtain the other's vertices and edges, and visa versa. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d0d325a5b24ec16077a4153a3c78a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0d325a5b24ec16077a4153a3c78a9a">&#9670;&nbsp;</a></span>update_levels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_levels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_disa_1_1_adjacency___graph.html">Adjacency_Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>parent_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; std::vector&lt; std::size_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>i_global_local</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the number of 'halo' levels/vertices around the primary sub-graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent_graph</td><td>The parent graph of this subgraph. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_level</td><td>The new number of levels the subgraph must have. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i_global_local</td><td>A global to local mapping of all vertices in the parent graph. Defaults to nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>i_global_local may be a nullptr. In this case it will be populated for adding levels, as a working vector is needed, but will be left as a nullptr when removing levels. Since no shrink-to-fit is called, multiple calls using the same pointer/vector can increase performance by avoiding repeated 'large' memory allocations. Finally, and std::numeric_limits&lt;std::size_t&gt;::max() value implies no mapping into this subgraph.</dd></dl>
<p>Updates the levels of the subgraph by either adding or removing levels from the parent graph depending on the current size vs the requested new size of the levels, max_level. Where adding occurs when max level is greater than the current levels, and removing when less than current. The new global to local mapping is returned through the i_global_local shared pointer. </p>

</div>
</div>
<a id="ae74963d1838b37a9db0a64a3bfb2813a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74963d1838b37a9db0a64a3bfb2813a">&#9670;&nbsp;</a></span>vertex_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t vertex_level </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>i_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the level of a given vertex in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i_vertex</td><td>The local index of the vertex whose level is to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The level of the vertex at the specified local index. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libs/graphing/<a class="el" href="adjacency__subgraph_8h_source.html">adjacency_subgraph.h</a></li>
<li>libs/graphing/<a class="el" href="adjacency__subgraph_8cpp.html">adjacency_subgraph.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_disa.html">Disa</a></li><li class="navelem"><a class="el" href="class_disa_1_1_adjacency___subgraph.html">Adjacency_Subgraph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
